<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RPG Checkers: Multiplayer</title>
    <style>
        /* --- CSS STYLES --- */
        :root {
            --slate-900: #0f172a; --slate-950: #020617; --slate-800: #1e293b;
            --slate-700: #334155; --slate-400: #94a3b8; --slate-100: #f1f5f9;
            --red-600: #dc2626; --red-400: #f87171;
            --blue-600: #2563eb; --blue-400: #60a5fa;
            --cyan-500: #06b6d4; --amber-100: #fef3c7;
            --stone-800: #292524; --yellow-500: #eab308;
            --emerald-500: #10b981;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, sans-serif;
            background-color: var(--slate-900); color: var(--slate-100);
            height: 100vh; height: 100dvh; display: flex; flex-direction: column; overflow: hidden;
            user-select: none;
        }

        /* FIX: Allow typing in inputs on mobile */
        input { user-select: auto !important; -webkit-user-select: auto !important; }

        /* Layout */
        .game-container { display: flex; flex-direction: column; height: 100%; width: 100%; max-width: 800px; margin: 0 auto; transition: filter 0.3s; }
        body.in-lobby .game-container { filter: blur(10px); pointer-events: none; }
        @media (min-width: 768px) { 
            .game-container { flex-direction: row; } 
            .player-panel { width: 300px; border-bottom: none !important; }
            .player-panel.left { border-right: 1px solid var(--slate-700); }
            .player-panel.right { border-left: 1px solid var(--slate-700); }
        }

        /* Panels */
        .player-panel { flex: 1; padding: 0.5rem; background: rgba(15, 23, 42, 0.95); display: flex; flex-direction: column; gap: 0.5rem; border-bottom: 1px solid var(--slate-700); transition: all 0.3s; z-index: 10; }
        .player-panel.active-turn { background: rgba(30, 41, 59, 1); box-shadow: 0 0 20px rgba(0,0,0,0.5); }

        /* Header */
        .player-header { display: flex; align-items: center; gap: 0.75rem; }
        .player-header.reverse { flex-direction: row-reverse; text-align: right; }
        .avatar { width: 2.5rem; height: 2.5rem; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.25rem; border: 2px solid; box-shadow: 0 0 10px rgba(0,0,0,0.3); transition: transform 0.3s; flex-shrink: 0; }
        .avatar.active { transform: scale(1.1); box-shadow: 0 0 15px currentColor; }
        .avatar.red { color: var(--red-400); background: var(--red-600); border-color: var(--red-400); }
        .avatar.blue { color: var(--blue-400); background: var(--blue-600); border-color: var(--blue-400); }
        .player-name { font-size: 1rem; font-weight: bold; margin: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .player-lvl { font-size: 0.7rem; color: var(--slate-400); }
        .text-red { color: var(--red-400); } .text-blue { color: var(--blue-400); }

        /* Stats & Spells */
        .stats-row { display: flex; gap: 0.5rem; }
        .stat-group { flex: 1; display: flex; flex-direction: column; gap: 2px; }
        .progress-bg { background: var(--slate-800); height: 6px; border-radius: 99px; overflow: hidden; position: relative; }
        .progress-bg.mana { height: 12px; border: 1px solid var(--slate-700); }
        .progress-fill { height: 100%; transition: width 0.3s ease; }
        .fill-xp { background: var(--yellow-500); }
        .fill-mana { background: linear-gradient(90deg, var(--blue-600), var(--blue-400)); }
        
        .spell-scroll { display: flex; gap: 0.5rem; overflow-x: auto; padding: 0.25rem 0; scrollbar-width: none; }
        .spell-scroll::-webkit-scrollbar { display: none; }
        .spell-btn { background: var(--slate-800); border: 1px solid var(--slate-700); color: white; padding: 0.4rem; border-radius: 6px; cursor: pointer; display: flex; flex-direction: column; align-items: center; min-width: 60px; height: 60px; flex-shrink: 0; transition: all 0.2s; }
        .spell-btn:hover:not(:disabled) { background: var(--slate-700); border-color: var(--slate-400); transform: translateY(-2px); }
        .spell-btn:disabled { opacity: 0.3; filter: grayscale(1); }
        .spell-icon { font-size: 1.25rem; margin-bottom: 2px; }
        .spell-name { font-size: 0.6rem; font-weight: bold; }
        .spell-cost { font-size: 0.55rem; color: var(--slate-400); }

        /* Center Board */
        .center-area { flex: 1; background: var(--slate-950); display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; padding: 0.5rem; }
        .turn-indicator { position: absolute; top: 1rem; background: rgba(15, 23, 42, 0.9); border: 1px solid var(--slate-700); padding: 0.4rem 1.2rem; border-radius: 99px; display: flex; align-items: center; gap: 0.5rem; font-weight: bold; font-size: 0.8rem; z-index: 20; box-shadow: 0 4px 10px rgba(0,0,0,0.5); pointer-events: auto; }
        .turn-indicator.combo { border-color: var(--yellow-500); animation: pulse 1s infinite; }
        .turn-dot { width: 8px; height: 8px; border-radius: 50%; }
        .bg-red { background: var(--red-600); } .bg-blue { background: var(--blue-600); }
        .cancel-link { font-size: 0.7rem; color: var(--red-400); text-decoration: underline; cursor: pointer; margin-left: 8px; }

        .board-container { width: 95vw; height: 95vw; max-width: 500px; max-height: 500px; background: var(--slate-800); border: 4px solid var(--slate-700); display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); box-shadow: 0 10px 30px rgba(0,0,0,0.5); border-radius: 8px; overflow: hidden; transition: transform 0.1s; }
        .board-container.shake { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }

        .cell { position: relative; display: flex; align-items: center; justify-content: center; }
        .cell.light { background: var(--amber-100); } .cell.dark { background: var(--stone-800); }
        .cell.highlight::after { content: ''; position: absolute; width: 25%; height: 25%; background: rgba(234, 179, 8, 0.8); border-radius: 50%; animation: pulse 1.5s infinite; }
        .cell.target { box-shadow: inset 0 0 0 3px #a855f7; cursor: pointer; }
        .cell.dimmed { filter: brightness(0.4); }

        .piece { width: 85%; height: 85%; border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 3px 6px rgba(0,0,0,0.6); transition: transform 0.2s; font-weight: bold; font-size: 1.2rem; position: relative; z-index: 5; }
        .piece.red { background: radial-gradient(circle at 30% 30%, #ef4444, #991b1b); border: 2px solid #7f1d1d; }
        .piece.blue { background: radial-gradient(circle at 30% 30%, #3b82f6, #1e40af); border: 2px solid #1e3a8a; }
        .piece.king { border: 3px solid var(--yellow-500); text-shadow: 0 2px 4px black; }
        .piece.selected { transform: scale(1.2); z-index: 10; border-color: white; }
        .piece.frozen { filter: brightness(1.2) hue-rotate(180deg) saturate(1.5); border-color: var(--cyan-500); }
        .piece.frozen::after { content: '‚ùÑÔ∏è'; font-size: 1rem; position: absolute; }
        .piece.shielded { box-shadow: 0 0 0 2px var(--emerald-500); }
        .piece.shielded::before { content: 'üõ°Ô∏è'; font-size: 0.8rem; position: absolute; bottom: 0; right: 0; }

        /* Log */
        .log-container { position: absolute; bottom: 10px; left: 10px; right: 10px; height: 60px; pointer-events: none; display: flex; flex-direction: column; justify-content: flex-end; text-shadow: 0 1px 2px black; font-size: 0.8rem; font-weight: bold; }
        .log-entry { background: rgba(0,0,0,0.6); padding: 4px 8px; border-radius: 4px; margin-top: 2px; align-self: center; width: fit-content; }
        .log-combat { color: var(--red-400); } .log-level { color: var(--yellow-500); } .log-magic { color: #c084fc; }

        /* Lobby */
        #lobby-overlay, .modal { position: fixed; inset: 0; background: rgba(2, 6, 23, 0.95); z-index: 200; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1rem; }
        .lobby-box, .modal-box { background: var(--slate-800); padding: 2rem; border-radius: 1rem; border: 1px solid var(--slate-700); text-align: center; width: 100%; max-width: 400px; box-shadow: 0 25px 50px rgba(0,0,0,0.5); }
        .lobby-title { font-size: 2rem; font-weight: bold; margin-bottom: 1.5rem; color: white; letter-spacing: 2px; }
        .lobby-btn, .modal-btn { width: 100%; padding: 1rem; margin-bottom: 0.75rem; background: var(--blue-600); border: none; border-radius: 0.5rem; color: white; font-weight: bold; font-size: 1rem; cursor: pointer; }
        .lobby-input { width: 100%; padding: 1rem; margin-bottom: 1rem; background: var(--slate-950); border: 1px solid var(--slate-700); border-radius: 0.5rem; color: white; font-size: 1.2rem; text-align: center; text-transform: uppercase; letter-spacing: 2px; }

        @keyframes pulse { 0% { transform: scale(0.9); opacity: 0.6; } 50% { transform: scale(1.1); opacity: 1; } 100% { transform: scale(0.9); opacity: 0.6; } }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-4px, 0, 0); } 40%, 60% { transform: translate3d(4px, 0, 0); } }
    </style>
</head>
<body class="in-lobby">

    <!-- LOBBY SCREEN -->
    <div id="lobby-overlay">
        <div class="lobby-box" id="lobby-main">
            <div class="lobby-title">RPG CHECKERS</div>
            <button class="lobby-btn" onclick="lobby.createGame()">CREATE GAME</button>
            <div style="margin: 1rem 0; color: var(--slate-400); font-size: 0.9rem;">‚Äî OR ‚Äî</div>
            <input type="text" id="room-code-input" class="lobby-input" placeholder="ROOM CODE" maxlength="6">
            <button class="lobby-btn secondary" onclick="lobby.joinGame()" style="background-color: var(--slate-700)">JOIN GAME</button>
            <div class="lobby-status" id="lobby-status"></div>
        </div>
        
        <div class="lobby-box" id="lobby-waiting" style="display: none;">
            <div class="lobby-title">WAITING...</div>
            <div style="color: var(--slate-400); margin-bottom: 1rem;">SHARE THIS CODE:</div>
            <div id="display-room-code" style="font-size: 3rem; font-weight: bold; color: var(--yellow-500); letter-spacing: 5px; margin-bottom: 2rem;"></div>
            <div class="lobby-status">Waiting for opponent to join...</div>
        </div>
    </div>

    <div class="game-container">
        <!-- TOP PANEL (RED) -->
        <div class="player-panel left" id="panel-red">
            <div class="player-header">
                <div class="avatar red" id="red-avatar">üëπ</div>
                <div>
                    <h2 class="player-name text-red">Red Warlocks</h2>
                    <div class="player-lvl">Level <span id="red-lvl">1</span></div>
                </div>
            </div>
            <!-- Stats -->
            <div class="stats-row">
                <div class="stat-group">
                    <div class="progress-bg"><div class="progress-fill fill-xp" id="red-xp-bar" style="width: 0%"></div></div>
                </div>
                <div class="stat-group">
                    <div class="progress-bg mana">
                        <div class="mana-text" id="red-mana-text">2/5</div>
                        <div class="progress-fill fill-mana" id="red-mana-bar" style="width: 40%"></div>
                    </div>
                </div>
            </div>
            <!-- Spells -->
            <div class="spell-scroll">
                <button class="spell-btn" id="btn-red-dash" onclick="game.activateSpell('dash')">
                    <span class="spell-icon">‚ö°</span>
                    <span class="spell-name">Dash</span>
                    <span class="spell-cost">2 Mana</span>
                </button>
                <button class="spell-btn" id="btn-red-freeze" onclick="game.activateSpell('freeze')">
                    <span class="spell-icon">‚ùÑÔ∏è</span>
                    <span class="spell-name">Freeze</span>
                    <span class="spell-cost">3 Mana</span>
                </button>
                <button class="spell-btn" id="btn-red-smite" onclick="game.activateSpell('smite')">
                    <span class="spell-icon">üî•</span>
                    <span class="spell-name">Smite</span>
                    <span class="spell-cost">4 Mana</span>
                </button>
            </div>
        </div>

        <!-- CENTER BOARD -->
        <div class="center-area">
            <div class="turn-indicator" id="turn-badge">
                <div class="turn-dot" id="turn-dot"></div>
                <span id="turn-text">RED'S TURN</span>
                <span id="cancel-spell" class="cancel-link" style="display: none;" onclick="game.cancelSpell()">Cancel</span>
            </div>

            <div class="board-container" id="board">
                <!-- Board generated by JS -->
            </div>

            <div class="log-container" id="game-log"></div>
        </div>

        <!-- BOTTOM PANEL (BLUE) -->
        <div class="player-panel right" id="panel-blue">
            <div class="player-header reverse">
                <div class="avatar blue" id="blue-avatar">üõ°Ô∏è</div>
                <div>
                    <h2 class="player-name text-blue">Blue Paladins</h2>
                    <div class="player-lvl">Level <span id="blue-lvl">1</span></div>
                </div>
            </div>
            <!-- Stats -->
            <div class="stats-row">
                <div class="stat-group">
                    <div class="progress-bg"><div class="progress-fill fill-xp" id="blue-xp-bar" style="width: 0%"></div></div>
                </div>
                <div class="stat-group">
                    <div class="progress-bg mana">
                        <div class="mana-text" id="blue-mana-text">2/5</div>
                        <div class="progress-fill fill-mana" id="blue-mana-bar" style="width: 40%"></div>
                    </div>
                </div>
            </div>
             <!-- Spells -->
             <div class="spell-scroll" style="justify-content: flex-end;">
                 <button class="spell-btn" id="btn-blue-dash" onclick="game.activateSpell('dash')">
                     <span class="spell-icon">‚ú®</span>
                     <span class="spell-name">Dash</span>
                     <span class="spell-cost">2 Mana</span>
                 </button>
                 <button class="spell-btn" id="btn-blue-freeze" onclick="game.activateSpell('freeze')">
                    <span class="spell-icon">‚ùÑÔ∏è</span>
                    <span class="spell-name">Freeze</span>
                    <span class="spell-cost">3 Mana</span>
                </button>
                 <button class="spell-btn" id="btn-blue-smite" onclick="game.activateSpell('smite')">
                     <span class="spell-icon">üî®</span>
                     <span class="spell-name">Smite</span>
                     <span class="spell-cost">4 Mana</span>
                 </button>
             </div>
        </div>
    </div>

    <!-- WIN MODAL -->
    <div class="modal" id="win-modal">
        <div class="modal-box">
            <div style="font-size: 5rem; margin-bottom: 1rem;">üèÜ</div>
            <h2 id="winner-name" style="font-size: 2.5rem; text-transform: uppercase; margin: 0; line-height: 1;">WINNER!</h2>
            <div style="color: var(--slate-400); margin-top: 0.5rem;">VICTORY ACHIEVED</div>
            <button class="modal-btn" onclick="location.reload()">Return to Lobby</button>
        </div>
    </div>

    <!-- FIREBASE SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, updateDoc, onSnapshot, getDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        // --- PASTE YOUR FIREBASE CONFIG HERE ---
        const firebaseConfig = {
            apiKey: "AIzaSyAw_6jPchQudpMb9m7ccOaH3uvx7P1QTXg",
            authDomain: "checkersrpg.firebaseapp.com",
            projectId: "checkersrpg",
            storageBucket: "checkersrpg.firebasestorage.app",
            messagingSenderId: "527317445442",
            appId: "1:527317445442:web:9c59dc55089c479ff076db",
            measurementId: "G-L7H2D9YXJT"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let myUserId = null;
        let myRoomId = null;
        let myRole = null; // 'red' or 'blue'

        // Auth immediately
        signInAnonymously(auth).then((userCredential) => {
            myUserId = userCredential.user.uid;
            console.log("Logged in as", myUserId);
        }).catch((error) => {
            document.getElementById('lobby-status').textContent = "Error: Could not connect to Auth";
            console.error(error);
        });

        // --- LOBBY LOGIC ---
        window.lobby = {
            async createGame() {
                if(!myUserId) return;
                const roomId = Math.random().toString(36).substring(2, 8).toUpperCase();
                myRole = 'red';
                myRoomId = roomId;

                // Initial Game State
                const gameState = {
                    board: JSON.stringify(game.createInitialBoard()),
                    turn: 'red',
                    // FIX: Ensure stats are initialized in DB correctly
                    stats: { 
                        red: { level: 1, xp: 0, xpNext: 100, mana: 2, maxMana: 5 }, 
                        blue: { level: 1, xp: 0, xpNext: 100, mana: 2, maxMana: 5 } 
                    },
                    players: { red: myUserId, blue: null },
                    status: 'waiting',
                    winner: null,
                    forcedPiece: null,
                    logs: [{msg: 'Room Created. Waiting for player...', type: 'info'}]
                };

                await setDoc(doc(db, "games", roomId), gameState);
                
                document.getElementById('lobby-main').style.display = 'none';
                document.getElementById('lobby-waiting').style.display = 'block';
                document.getElementById('display-room-code').textContent = roomId;

                this.subscribeToGame(roomId);
            },

            async joinGame() {
                if(!myUserId) return;
                const roomId = document.getElementById('room-code-input').value.toUpperCase();
                if(roomId.length < 2) return;

                const gameRef = doc(db, "games", roomId);
                const gameSnap = await getDoc(gameRef);

                if (gameSnap.exists()) {
                    const data = gameSnap.data();
                    if(data.players.blue && data.players.blue !== myUserId) {
                        document.getElementById('lobby-status').textContent = "Room is full!";
                        return;
                    }

                    myRole = 'blue';
                    myRoomId = roomId;

                    // FIX: Safer log update
                    const currentLogs = data.logs || [];
                    const newLogs = [...currentLogs, {msg: 'Blue Player Joined! Game Start.', type: 'info'}];

                    // Join logic
                    await updateDoc(gameRef, {
                        "players.blue": myUserId,
                        status: 'playing',
                        logs: newLogs
                    });

                    this.subscribeToGame(roomId);
                } else {
                    document.getElementById('lobby-status').textContent = "Room not found!";
                }
            },
            
            subscribeToGame(roomId) {
                onSnapshot(doc(db, "games", roomId), (doc) => {
                    const data = doc.data();
                    if(!data) return;

                    // Lobby Transition
                    if(data.status === 'playing') {
                        document.body.classList.remove('in-lobby');
                        document.getElementById('lobby-overlay').style.display = 'none';
                    }

                    // Sync State
                    game.board = JSON.parse(data.board);
                    game.turn = data.turn;
                    game.stats = data.stats; // This will now have correct data
                    game.forcedPiece = data.forcedPiece;
                    game.winner = data.winner;
                    
                    // Sync Logs (Safely)
                    const logContainer = document.getElementById('game-log');
                    logContainer.innerHTML = '';
                    if(data.logs && Array.isArray(data.logs)) {
                        data.logs.slice().reverse().forEach(l => game.renderLog(l.msg, l.type));
                    }

                    if(data.winner) {
                        game.winGame(data.winner);
                    }

                    game.render();
                });
            }
        };

        // --- GAME LOGIC ---
        window.game = {
            board: [],
            turn: 'red',
            // FIX: Initialize stats locally too
            stats: { 
                red: { level: 1, xp: 0, xpNext: 100, mana: 2, maxMana: 5 }, 
                blue: { level: 1, xp: 0, xpNext: 100, mana: 2, maxMana: 5 } 
            },
            activeSpell: null,
            forcedPiece: null,
            selected: null,
            
            createInitialBoard() {
                let b = [];
                for(let r=0; r<8; r++) {
                    const row = [];
                    for(let c=0; c<8; c++) {
                        let piece = null;
                        if((r+c)%2 !== 0) {
                            if(r < 3) piece = { player: 'blue', isKing: false, frozen: 0 };
                            if(r > 4) piece = { player: 'red', isKing: false, frozen: 0 };
                        }
                        row.push({ piece: piece, highlight: false, target: false });
                    }
                    b.push(row);
                }
                return b;
            },

            // CORE NETWORK ACTION
            async pushUpdate(newBoard, newStats, nextTurn, newForcedPiece, logMsg, logType) {
                if(!myRoomId) return;
                
                const gameRef = doc(db, "games", myRoomId);
                const snap = await getDoc(gameRef);
                const currentLogs = snap.data().logs || [];
                const newLogs = [...currentLogs, {msg: logMsg, type: logType}];

                await updateDoc(gameRef, {
                    board: JSON.stringify(newBoard),
                    stats: newStats,
                    turn: nextTurn,
                    forcedPiece: newForcedPiece,
                    logs: newLogs
                });
            },

            // --- INTERACTION ---

            handleClick(r, c) {
                if(this.turn !== myRole) return;
                if(window.game.winner) return;

                if(this.activeSpell) {
                    this.castSpell(r, c);
                    return;
                }

                const cell = this.board[r][c];
                
                if(cell.piece && cell.piece.player === this.turn) {
                    if (this.forcedPiece) {
                        if (this.forcedPiece.r !== r || this.forcedPiece.c !== c) return; 
                    }
                    if(cell.piece.frozen > 0) return;

                    this.selected = {r, c};
                    this.highlightMoves(r, c, cell.piece);
                    this.render();
                    return;
                }

                if(cell.highlight && this.selected) {
                    this.movePiece(this.selected.r, this.selected.c, r, c);
                }
            },

            highlightMoves(r, c, piece) {
                this.board.forEach(row => row.forEach(cell => cell.highlight = false));
                const moves = this.getValidMoves(r, c, piece);
                moves.forEach(m => {
                    this.board[m.r][m.c].highlight = true;
                });
            },

            getValidMoves(r, c, piece) {
                if (piece.frozen > 0) return [];
                const moves = [];
                const forward = piece.player === 'red' ? -1 : 1;
                const dirs = piece.isKing ? [-1, 1] : [forward];

                dirs.forEach(dr => {
                    [-1, 1].forEach(dc => {
                        const nr = r + dr, nc = c + dc;
                        
                        if(this.isValid(nr, nc)) {
                            if(!this.forcedPiece && !this.board[nr][nc].piece) {
                                moves.push({r: nr, c: nc});
                            }
                            else if(this.board[nr][nc].piece && this.board[nr][nc].piece.player !== piece.player) {
                                const jr = nr + dr + dr, jc = nc + dc + dc; 
                                if(this.isValid(jr, jc) && !this.board[jr][jc].piece) {
                                     moves.push({r: jr, c: jc});
                                }
                            }
                        }
                    });
                });
                return moves;
            },

            async movePiece(fr, fc, tr, tc) {
                let nextBoard = JSON.parse(JSON.stringify(this.board));
                let nextStats = JSON.parse(JSON.stringify(this.stats));
                const piece = nextBoard[fr][fc].piece;
                const isJump = Math.abs(tr - fr) > 1;
                let logMsg = '';
                let logType = 'info';

                nextBoard[tr][tc].piece = piece;
                nextBoard[fr][fc].piece = null;
                nextBoard.forEach(row => row.forEach(c => c.highlight = false));

                let nextForcedPiece = null;
                let turnEnds = true;

                if(isJump) {
                    const midR = (fr + tr) / 2;
                    const midC = (fc + tc) / 2;
                    nextBoard[midR][midC].piece = null;
                    
                    logMsg = `${this.turn.toUpperCase()} crushed an enemy!`;
                    logType = 'combat';
                    
                    nextStats[this.turn].xp += 50;
                    if(nextStats[this.turn].xp >= nextStats[this.turn].xpNext) {
                         nextStats[this.turn].level++;
                         nextStats[this.turn].xp -= nextStats[this.turn].xpNext;
                         nextStats[this.turn].xpNext = Math.floor(nextStats[this.turn].xpNext * 1.5);
                         nextStats[this.turn].maxMana += 2;
                         nextStats[this.turn].mana = nextStats[this.turn].maxMana;
                         logMsg += " And Leveled Up!";
                    }

                    const forward = piece.player === 'red' ? -1 : 1;
                    const dirs = piece.isKing ? [-1, 1] : [forward];
                    let canJumpAgain = false;
                    
                    dirs.forEach(dr => {
                        [-1, 1].forEach(dc => {
                            const jr = tr + dr + dr, jc = tc + dc + dc;
                            const mr = tr + dr, mc = tc + dc;
                            if(jr>=0 && jr<8 && jc>=0 && jc<8 && !nextBoard[jr][jc].piece) {
                                if(nextBoard[mr][mc].piece && nextBoard[mr][mc].piece.player !== piece.player) {
                                    canJumpAgain = true;
                                }
                            }
                        });
                    });

                    if (canJumpAgain) {
                        nextForcedPiece = {r: tr, c: tc};
                        turnEnds = false;
                        logMsg += " COMBO!";
                    }
                }

                if((piece.player === 'red' && tr === 0) || (piece.player === 'blue' && tr === 7)) {
                    if(!piece.isKing) {
                        piece.isKing = true;
                        logMsg = "Promoted to King!";
                        logType = 'level';
                        nextStats[this.turn].xp += 20;
                        nextForcedPiece = null; 
                        turnEnds = true;
                    }
                }

                let nextTurn = this.turn;
                if (turnEnds) {
                    nextTurn = this.turn === 'red' ? 'blue' : 'red';
                    if(nextStats[nextTurn].mana < nextStats[nextTurn].maxMana) {
                        nextStats[nextTurn].mana++;
                    }
                    nextBoard.forEach(row => row.forEach(cell => {
                        if (cell.piece && cell.piece.player === nextTurn && cell.piece.frozen > 0) {
                            cell.piece.frozen--;
                        }
                    }));
                }

                await this.pushUpdate(nextBoard, nextStats, nextTurn, nextForcedPiece, logMsg || "Moved piece", logType);
                this.selected = null;
            },

            activateSpell(spellName) {
                if(this.turn !== myRole) return;
                
                if(this.activeSpell === spellName) {
                    this.cancelSpell();
                    return;
                }
                this.activeSpell = spellName;
                
                this.board.forEach((row, r) => row.forEach((cell, c) => {
                    cell.target = false;
                    cell.highlight = false; 
                    
                    if(spellName === 'smite' || spellName === 'freeze') {
                        if(cell.piece && cell.piece.player !== this.turn) cell.target = true;
                    } 
                    else if(spellName === 'dash') {
                        if(cell.piece && cell.piece.player === this.turn && cell.piece.frozen === 0) cell.target = true;
                    }
                }));
                this.render();
            },

            cancelSpell() {
                this.activeSpell = null;
                this.board.forEach(row => row.forEach(cell => cell.target = false));
                this.render();
            },

            async castSpell(r, c) {
                const cell = this.board[r][c];
                if(!cell.target) return;

                let nextBoard = JSON.parse(JSON.stringify(this.board));
                let nextStats = JSON.parse(JSON.stringify(this.stats));
                let logMsg = '';
                
                if(this.activeSpell === 'smite') {
                    nextStats[this.turn].mana -= 4;
                    nextBoard[r][c].piece = null;
                    logMsg = "SMITE!";
                    nextStats[this.turn].xp += 30;
                }
                else if(this.activeSpell === 'freeze') {
                    nextStats[this.turn].mana -= 3;
                    nextBoard[r][c].piece.frozen = 2;
                    logMsg = "FROZEN!";
                }
                else if(this.activeSpell === 'dash') {
                    nextStats[this.turn].mana -= 2;
                    const piece = nextBoard[r][c].piece;
                    const dir = this.turn === 'red' ? -1 : 1;
                    let tr = r + (dir * 2);
                    if(tr < 0) tr = 0; if(tr > 7) tr = 7;
                    
                    if(this.isValid(tr, c) && !nextBoard[tr][c].piece) {
                        nextBoard[tr][c].piece = piece;
                        nextBoard[r][c].piece = null;
                        logMsg = "DASHED forward!";
                    } else if (this.isValid(r+dir, c) && !nextBoard[r+dir][c].piece) {
                        nextBoard[r+dir][c].piece = piece;
                        nextBoard[r][c].piece = null;
                        logMsg = "DASHED (short)!";
                    }
                }

                let nextTurn = this.turn === 'red' ? 'blue' : 'red';
                if(nextStats[nextTurn].mana < nextStats[nextTurn].maxMana) nextStats[nextTurn].mana++;
                 nextBoard.forEach(row => row.forEach(cell => {
                    if (cell.piece && cell.piece.player === nextTurn && cell.piece.frozen > 0) {
                        cell.piece.frozen--;
                    }
                }));

                await this.pushUpdate(nextBoard, nextStats, nextTurn, null, logMsg, 'magic');
                this.activeSpell = null;
            },

            isValid(r, c) { return r>=0 && r<8 && c>=0 && c<8; },

            renderLog(msg, type) {
                const logEl = document.getElementById('game-log');
                const entry = document.createElement('div');
                entry.className = `log-entry log-${type}`;
                entry.textContent = `> ${msg}`;
                logEl.prepend(entry);
            },

            winGame(winner) {
                this.winner = winner;
                document.getElementById('winner-name').textContent = winner + " WINS!";
                document.getElementById('winner-name').style.color = winner === 'red' ? 'var(--red-400)' : 'var(--blue-400)';
                document.getElementById('win-modal').classList.add('active');
                
                if(myRoomId) {
                     updateDoc(doc(db, "games", myRoomId), { winner: winner });
                }
            },

            render() {
                const boardEl = document.getElementById('board');
                boardEl.innerHTML = '';
                
                this.board.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        const cellDiv = document.createElement('div');
                        cellDiv.className = `cell ${(r+c)%2===0 ? 'light' : 'dark'}`;
                        if(cell.highlight) cellDiv.classList.add('highlight');
                        if(cell.target) cellDiv.classList.add('target');
                        if(this.activeSpell && !cell.target) cellDiv.classList.add('dimmed');

                        cellDiv.onclick = () => this.handleClick(r, c);

                        if(cell.piece) {
                            const p = document.createElement('div');
                            p.className = `piece ${cell.piece.player}`;
                            if(cell.piece.isKing) p.classList.add('king');
                            if(cell.piece.frozen > 0) p.classList.add('frozen');
                            if(this.selected && this.selected.r === r && this.selected.c === c) p.classList.add('selected');
                            
                            if (cell.piece.isKing) {
                                p.innerHTML = 'üëë';
                            }
                            cellDiv.appendChild(p);
                        }
                        boardEl.appendChild(cellDiv);
                    });
                });

                ['red', 'blue'].forEach(p => {
                    const s = this.stats[p];
                    if(s) {
                        document.getElementById(`${p}-lvl`).textContent = s.level;
                        document.getElementById(`${p}-xp-text`).textContent = `${s.xp}/${s.xpNext}`;
                        document.getElementById(`${p}-xp-bar`).style.width = `${(s.xp/s.xpNext)*100}%`;
                        document.getElementById(`${p}-mana-text`).textContent = `${s.mana}/${s.maxMana}`;
                        document.getElementById(`${p}-mana-bar`).style.width = `${(s.mana/s.maxMana)*100}%`;
                    }
                });

                const isMyTurn = (this.turn === myRole);
                const mana = this.stats[myRole]?.mana || 0;
                
                document.getElementById('btn-red-dash').disabled = !(isMyTurn && myRole==='red' && mana >= 2);
                document.getElementById('btn-red-freeze').disabled = !(isMyTurn && myRole==='red' && mana >= 3);
                document.getElementById('btn-red-smite').disabled = !(isMyTurn && myRole==='red' && mana >= 4);

                document.getElementById('btn-blue-dash').disabled = !(isMyTurn && myRole==='blue' && mana >= 2);
                document.getElementById('btn-blue-freeze').disabled = !(isMyTurn && myRole==='blue' && mana >= 3);
                document.getElementById('btn-blue-smite').disabled = !(isMyTurn && myRole==='blue' && mana >= 4);

                const dot = document.getElementById('turn-dot');
                const txt = document.getElementById('turn-text');
                const cancel = document.getElementById('cancel-spell');
                const badge = document.getElementById('turn-badge');
                
                document.getElementById('red-avatar').classList.toggle('active', this.turn === 'red');
                document.getElementById('blue-avatar').classList.toggle('active', this.turn === 'blue');

                dot.className = `turn-dot ${this.turn === 'red' ? 'bg-red' : 'bg-blue'}`;
                
                if (this.forcedPiece) {
                    badge.className = 'turn-indicator combo';
                    txt.textContent = "COMBO! JUMP AGAIN!";
                    cancel.style.display = 'none';
                } else if(this.activeSpell) {
                    badge.className = 'turn-indicator';
                    txt.textContent = `CASTING: ${this.activeSpell.toUpperCase()}`;
                    cancel.style.display = 'inline';
                } else {
                    badge.className = 'turn-indicator';
                    txt.textContent = `${this.turn.toUpperCase()}'S TURN`;
                    cancel.style.display = 'none';
                }
            }
        };
    </script>
</body>
</html>