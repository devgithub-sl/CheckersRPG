<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RPG Checkers: Mobile Edition</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --panel-bg: #1e293b;
            --board-dark: #334155;
            --board-light: #cbd5e1;
            --red-p: #ef4444;
            --blue-p: #3b82f6;
            --gold: #fbbf24;
            --mana: #60a5fa;
            --accent: #8b5cf6;
        }

        * { box-sizing: border-box; touch-action: manipulation; user-select: none; -webkit-user-select: none; }
        
        body {
            margin: 0; padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg-color);
            color: white;
            height: 100dvh; /* Dynamic viewport height for mobile */
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- UTILS --- */
        .hidden { display: none !important; }
        .flex { display: flex; }
        .col { flex-direction: column; }
        .center { align-items: center; justify-content: center; }
        .shake { animation: shake 0.4s; }

        /* --- LOBBY UI --- */
        #lobby-screen {
            position: fixed; inset: 0; z-index: 100;
            background: var(--bg-color);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            gap: 20px; padding: 20px;
        }
        
        .title { font-size: 2.5rem; font-weight: 800; color: var(--gold); letter-spacing: 2px; text-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        .card { background: var(--panel-bg); padding: 2rem; border-radius: 16px; width: 100%; max-width: 400px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); text-align: center; }
        
        input { 
            width: 100%; padding: 12px; margin: 10px 0; border-radius: 8px; border: none; 
            background: #020617; color: white; font-size: 1.2rem; text-align: center; letter-spacing: 2px;
            user-select: auto !important; -webkit-user-select: auto !important; /* Allow typing */
        }
        
        .btn {
            width: 100%; padding: 14px; border: none; border-radius: 8px;
            font-weight: bold; font-size: 1rem; cursor: pointer; transition: transform 0.1s;
            text-transform: uppercase; margin-bottom: 8px;
        }
        .btn-primary { background: var(--blue-p); color: white; }
        .btn-secondary { background: var(--board-dark); color: #94a3b8; }
        .btn:active { transform: scale(0.98); }

        /* --- GAME UI LAYOUT --- */
        #game-screen { flex: 1; display: flex; flex-direction: column; width: 100%; max-width: 600px; margin: 0 auto; }

        /* Player Stats Bar */
        .player-bar {
            padding: 10px 15px; background: var(--panel-bg);
            display: flex; align-items: center; justify-content: space-between;
            border-bottom: 1px solid var(--board-dark);
            height: 70px;
        }
        .player-bar.bottom { border-top: 1px solid var(--board-dark); border-bottom: none; height: auto; flex-direction: column; gap: 10px; padding-bottom: 20px; }

        .avatar-group { display: flex; align-items: center; gap: 10px; }
        .avatar { width: 40px; height: 40px; border-radius: 50%; border: 2px solid #555; display: grid; place-items: center; font-size: 1.2rem; transition: all 0.3s; }
        .avatar.active { border-color: var(--gold); box-shadow: 0 0 15px var(--gold); transform: scale(1.1); }
        
        .bars { flex: 1; margin-left: 15px; display: flex; flex-direction: column; gap: 4px; }
        .bar-container { width: 100%; height: 6px; background: #0f172a; border-radius: 4px; overflow: hidden; }
        .bar-fill { height: 100%; transition: width 0.5s; }
        .xp-fill { background: var(--gold); }
        .mana-fill { background: var(--mana); }
        
        /* Board Area */
        .board-wrapper { flex: 1; display: grid; place-items: center; background: #020617; position: relative; }
        #board {
            width: 95vw; height: 95vw; max-width: 500px; max-height: 500px;
            display: grid; grid-template-columns: repeat(8, 1fr);
            background: var(--board-dark); border: 4px solid var(--panel-bg);
            border-radius: 8px; overflow: hidden;
        }

        .cell { position: relative; width: 100%; height: 100%; }
        .cell.light { background: var(--board-light); }
        .cell.dark { background: var(--board-dark); }
        .cell.highlight::after {
            content: ''; position: absolute; inset: 20%; background: rgba(251, 191, 36, 0.6);
            border-radius: 50%; animation: pulse 1s infinite; pointer-events: none;
        }
        .cell.target { box-shadow: inset 0 0 0 3px var(--accent); }

        /* Pieces */
        .piece {
            width: 80%; height: 80%; border-radius: 50%;
            position: absolute; top: 10%; left: 10%;
            box-shadow: 0 4px 6px rgba(0,0,0,0.5);
            display: grid; place-items: center; font-size: 1.2rem; font-weight: bold;
            transition: transform 0.2s;
        }
        .piece.red { background: radial-gradient(circle at 30% 30%, #ef4444, #991b1b); border: 2px solid #7f1d1d; }
        .piece.blue { background: radial-gradient(circle at 30% 30%, #3b82f6, #1e40af); border: 2px solid #1e3a8a; }
        .piece.king { border: 3px solid var(--gold); color: var(--gold); text-shadow: 0 2px 0 #000; }
        .piece.selected { transform: scale(1.2); z-index: 10; border-color: white; }
        
        /* Status Effects */
        .piece.frozen { filter: hue-rotate(180deg) brightness(1.2); border-color: cyan; }
        .piece.shielded { box-shadow: 0 0 0 2px var(--emerald-500); }
        .piece.shielded::after { content: 'üõ°Ô∏è'; font-size: 0.8rem; position: absolute; bottom: -2px; right: -2px; }

        /* Spell Dock (Bottom) */
        .spell-dock {
            width: 100%; overflow-x: auto; display: flex; gap: 8px; padding: 4px;
            scrollbar-width: none;
        }
        .spell-card {
            min-width: 60px; height: 70px; background: #334155; border-radius: 8px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            border: 1px solid #475569; position: relative;
        }
        .spell-card.active { background: var(--accent); border-color: white; transform: translateY(-4px); }
        .spell-card:disabled { opacity: 0.3; filter: grayscale(1); }
        .spell-cost { font-size: 0.6rem; position: absolute; top: 2px; right: 4px; color: var(--mana); }
        .spell-icon { font-size: 1.5rem; margin-bottom: 2px; }
        .spell-name { font-size: 0.6rem; font-weight: bold; text-transform: uppercase; }

        /* Floating Text & Notifications */
        #turn-banner {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); padding: 5px 15px; border-radius: 20px;
            font-size: 0.8rem; font-weight: bold; border: 1px solid #555; z-index: 20;
        }
        .float-text {
            position: absolute; color: var(--gold); font-weight: bold; font-size: 1.2rem;
            animation: floatUp 1s forwards; pointer-events: none; z-index: 50; text-shadow: 0 2px 4px black;
        }

        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        @keyframes floatUp { 0% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(-30px); opacity: 0; } }

    </style>
</head>
<body>

    <!-- LOBBY -->
    <div id="lobby-screen">
        <div class="title">RPG CHECKERS</div>
        <div class="card">
            <h3>Start a Match</h3>
            <button class="btn btn-primary" onclick="app.createGame()">Create New Room</button>
            <div style="margin: 15px 0; color: #64748b;">‚Äî OR ‚Äî</div>
            <input type="text" id="room-input" placeholder="ENTER CODE" maxlength="6">
            <button class="btn btn-secondary" onclick="app.joinGame()">Join Room</button>
            <div id="lobby-msg" style="margin-top:10px; color: var(--gold); min-height: 20px;"></div>
        </div>
    </div>

    <!-- GAME -->
    <div id="game-screen" class="hidden">
        
        <!-- Opponent (Top) -->
        <div class="player-bar">
            <div class="avatar-group">
                <div class="avatar red" id="av-red">üëπ</div>
                <div>
                    <div style="font-weight:bold; color:var(--red-p)">Red Warlocks</div>
                    <div style="font-size:0.7rem; color:#94a3b8">Lvl <span id="lvl-red">1</span></div>
                </div>
            </div>
            <div class="bars">
                <div class="bar-container"><div class="bar-fill xp-fill" id="xp-red" style="width:0%"></div></div>
                <div class="bar-container"><div class="bar-fill mana-fill" id="mana-red" style="width:100%"></div></div>
            </div>
        </div>

        <!-- Board -->
        <div class="board-wrapper">
            <div id="turn-banner">WAITING...</div>
            <div id="board"></div>
        </div>

        <!-- Self (Bottom) -->
        <div class="player-bar bottom">
            <div style="display:flex; justify-content:space-between; width:100%; align-items:center;">
                <div class="avatar-group">
                    <div class="avatar blue" id="av-blue">üõ°Ô∏è</div>
                    <div>
                        <div style="font-weight:bold; color:var(--blue-p)">Blue Paladins</div>
                        <div style="font-size:0.7rem; color:#94a3b8">Lvl <span id="lvl-blue">1</span></div>
                    </div>
                </div>
                <div class="bars" style="max-width: 150px;">
                    <div class="bar-container"><div class="bar-fill xp-fill" id="xp-blue" style="width:0%"></div></div>
                    <div class="bar-container"><div class="bar-fill mana-fill" id="mana-blue" style="width:100%"></div></div>
                </div>
            </div>

            <!-- Spell Dock -->
            <div class="spell-dock" id="spell-dock">
                <!-- Spells injected by JS -->
            </div>
        </div>
    </div>

    <!-- FIREBASE & LOGIC -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, updateDoc, onSnapshot, getDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        // -----------------------------------------------------
        // 1. CONFIGURATION (PASTE YOUR KEYS HERE)
        // -----------------------------------------------------
        const firebaseConfig = {
            apiKey: "AIzaSyAw_6jPchQudpMb9m7ccOaH3uvx7P1QTXg",
            authDomain: "checkersrpg.firebaseapp.com",
            projectId: "checkersrpg",
            storageBucket: "checkersrpg.firebasestorage.app",
            messagingSenderId: "527317445442",
            appId: "1:527317445442:web:9c59dc55089c479ff076db",
            measurementId: "G-L7H2D9YXJT"
        };

        // Initialize Firebase
        let db, auth, userId;
        const isOnline = !!firebaseConfig.apiKey;

        if (isOnline) {
            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            signInAnonymously(auth).then(u => userId = u.user.uid).catch(console.error);
        } else {
            console.warn("No Firebase keys! Offline mode.");
            userId = "offline-user";
        }

        // -----------------------------------------------------
        // 2. GAME CONSTANTS & STATE
        // -----------------------------------------------------
        const SPELLS = [
            { id: 'dash', name: 'Dash', icon: '‚ö°', cost: 2, desc: 'Move again' },
            { id: 'shield', name: 'Shield', icon: 'üõ°Ô∏è', cost: 2, desc: 'Prevent capture' },
            { id: 'freeze', name: 'Freeze', icon: '‚ùÑÔ∏è', cost: 3, desc: 'Stop movement' },
            { id: 'smite', name: 'Smite', icon: 'üî•', cost: 4, desc: 'Destroy unit' },
            { id: 'revive', name: 'Revive', icon: 'üíÄ', cost: 5, desc: 'Spawn unit' }
        ];

        let state = {
            roomId: null,
            role: 'red', // 'red' or 'blue'
            board: [], // 8x8 grid
            turn: 'red',
            stats: {
                red: { lvl: 1, xp: 0, xpMax: 100, mana: 2, manaMax: 5 },
                blue: { lvl: 1, xp: 0, xpMax: 100, mana: 2, manaMax: 5 }
            },
            selected: null, // {r, c}
            activeSpell: null,
            forcedPiece: null, // {r, c} for combos
            winner: null
        };

        // -----------------------------------------------------
        // 3. GAME ENGINE (LOGIC)
        // -----------------------------------------------------
        const Engine = {
            createBoard() {
                let b = Array(8).fill(null).map(() => Array(8).fill(null));
                for(let r=0; r<8; r++) {
                    for(let c=0; c<8; c++) {
                        if ((r+c)%2 !== 0) {
                            if (r < 3) b[r][c] = { player: 'blue', king: false, frozen: 0, shielded: 0 };
                            if (r > 4) b[r][c] = { player: 'red', king: false, frozen: 0, shielded: 0 };
                        }
                    }
                }
                return b;
            },

            getValidMoves(board, r, c, piece, forced) {
                if (piece.frozen > 0) return [];
                if (forced && (forced.r !== r || forced.c !== c)) return [];

                let moves = [];
                let dirs = piece.king ? [[-1,-1], [-1,1], [1,-1], [1,1]] : (piece.player === 'red' ? [[-1,-1], [-1,1]] : [[1,-1], [1,1]]);

                dirs.forEach(([dr, dc]) => {
                    let nr = r + dr, nc = c + dc;
                    if (this.inBounds(nr, nc)) {
                        // Walk (only if not forced to jump)
                        if (!board[nr][nc] && !forced) {
                            moves.push({ r: nr, c: nc, type: 'walk' });
                        }
                        // Jump
                        else if (board[nr][nc] && board[nr][nc].player !== piece.player) {
                            // Check if enemy shielded
                            if (board[nr][nc].shielded > 0) return;

                            let jr = nr + dr, jc = nc + dc;
                            if (this.inBounds(jr, jc) && !board[jr][jc]) {
                                moves.push({ r: jr, c: jc, type: 'jump', killR: nr, killC: nc });
                            }
                        }
                    }
                });
                return moves;
            },

            inBounds(r, c) { return r >= 0 && r < 8 && c >= 0 && c < 8; },

            // Process a move and return NEW state (pure function-ish)
            processMove(currentState, fromR, fromC, move) {
                let s = JSON.parse(JSON.stringify(currentState)); // Deep copy
                let p = s.board[fromR][fromC];
                
                // Execute Move
                s.board[move.r][move.c] = p;
                s.board[fromR][fromC] = null;
                
                let turnEnds = true;
                s.forcedPiece = null;

                if (move.type === 'jump') {
                    s.board[move.killR][move.killC] = null;
                    Renderer.showFloatText(move.killC, move.killR, "CRUSH!");
                    
                    // XP Gain
                    this.gainXp(s, s.turn, 50);

                    // Combo Check
                    let followUps = this.getValidMoves(s.board, move.r, move.c, p, null).filter(m => m.type === 'jump');
                    if (followUps.length > 0) {
                        s.forcedPiece = { r: move.r, c: move.c };
                        turnEnds = false;
                        Renderer.showFloatText(move.c, move.r, "COMBO!");
                    }
                }

                // King Promotion
                if ((p.player === 'red' && move.r === 0) || (p.player === 'blue' && move.r === 7)) {
                    if (!p.king) {
                        p.king = true;
                        this.gainXp(s, s.turn, 20);
                        Renderer.showFloatText(move.c, move.r, "KING!");
                        turnEnds = true; // Promotion ends turn always
                        s.forcedPiece = null;
                    }
                }

                if (turnEnds) {
                    this.endTurn(s);
                }

                return s;
            },

            castSpell(currentState, r, c) {
                let s = JSON.parse(JSON.stringify(currentState));
                let spell = s.activeSpell;
                let cost = SPELLS.find(sp => sp.id === spell).cost;
                let target = s.board[r][c];
                let pStats = s.stats[s.turn];

                if (pStats.mana < cost) return null; // Should be blocked by UI anyway

                let success = false;

                if (spell === 'smite' && target && target.player !== s.turn && target.shielded === 0) {
                    s.board[r][c] = null;
                    this.gainXp(s, s.turn, 30);
                    success = true;
                } else if (spell === 'freeze' && target && target.player !== s.turn) {
                    target.frozen = 2;
                    success = true;
                } else if (spell === 'shield' && target && target.player === s.turn) {
                    target.shielded = 2;
                    success = true;
                } else if (spell === 'dash' && target && target.player === s.turn) {
                    // Simple dash: teleport forward 2 spaces if empty
                    let dir = s.turn === 'red' ? -1 : 1;
                    let tr = r + (dir*2);
                    if (this.inBounds(tr, c) && !s.board[tr][c]) {
                        s.board[tr][c] = target;
                        s.board[r][c] = null;
                        success = true;
                    }
                } else if (spell === 'revive' && !target) {
                    // Spawn on back row
                    let row = s.turn === 'red' ? 7 : 0;
                    if (r === row) {
                        s.board[r][c] = { player: s.turn, king: false, frozen: 0, shielded: 0 };
                        success = true;
                    }
                }

                if (success) {
                    pStats.mana -= cost;
                    s.activeSpell = null;
                    this.endTurn(s);
                    return s;
                }
                return null;
            },

            gainXp(s, player, amount) {
                let stats = s.stats[player];
                stats.xp += amount;
                if (stats.xp >= stats.xpMax) {
                    stats.lvl++;
                    stats.xp = 0;
                    stats.xpMax = Math.floor(stats.xpMax * 1.2);
                    stats.manaMax += 1;
                    stats.mana = stats.manaMax; // Refill
                    Renderer.showFloatText(3, 3, `${player.toUpperCase()} LVL UP!`);
                }
            },

            endTurn(s) {
                let next = s.turn === 'red' ? 'blue' : 'red';
                // Mana Regen
                if (s.stats[next].mana < s.stats[next].manaMax) s.stats[next].mana++;
                // Tick Effects
                for(let r=0; r<8; r++) {
                    for(let c=0; c<8; c++) {
                        let p = s.board[r][c];
                        if (p && p.player === next) {
                            if (p.frozen > 0) p.frozen--;
                            if (p.shielded > 0) p.shielded--;
                        }
                    }
                }
                s.turn = next;
                
                // Win Check
                let hasRed = s.board.some(row => row.some(c => c && c.player === 'red'));
                let hasBlue = s.board.some(row => row.some(c => c && c.player === 'blue'));
                if (!hasRed) s.winner = 'blue';
                if (!hasBlue) s.winner = 'red';
            }
        };

        // -----------------------------------------------------
        // 4. UI RENDERER
        // -----------------------------------------------------
        const Renderer = {
            init() {
                const dock = document.getElementById('spell-dock');
                dock.innerHTML = SPELLS.map(s => `
                    <button class="spell-card" onclick="app.clickSpell('${s.id}')" id="btn-${s.id}">
                        <div class="spell-cost">${s.cost}</div>
                        <div class="spell-icon">${s.icon}</div>
                        <div class="spell-name">${s.name}</div>
                    </button>
                `).join('');
            },

            draw() {
                // Panels
                const isRed = state.turn === 'red';
                document.getElementById('av-red').classList.toggle('active', isRed);
                document.getElementById('av-blue').classList.toggle('active', !isRed);
                document.getElementById('turn-banner').textContent = state.winner ? `${state.winner.toUpperCase()} WINS!` : `${state.turn.toUpperCase()}'S TURN`;

                // Stats
                ['red', 'blue'].forEach(p => {
                    const s = state.stats[p];
                    document.getElementById(`lvl-${p}`).textContent = s.lvl;
                    document.getElementById(`xp-${p}`).style.width = `${(s.xp/s.xpMax)*100}%`;
                    document.getElementById(`mana-${p}`).style.width = `${(s.mana/s.manaMax)*100}%`;
                });

                // Spells
                const myMana = state.stats[state.role].mana;
                const myTurn = state.turn === state.role;
                SPELLS.forEach(s => {
                    const btn = document.getElementById(`btn-${s.id}`);
                    btn.disabled = !myTurn || myMana < s.cost;
                    btn.classList.toggle('active', state.activeSpell === s.id);
                });

                // Board
                const boardEl = document.getElementById('board');
                boardEl.innerHTML = ''; // Clear (simple redraw)
                
                state.board.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        const div = document.createElement('div');
                        div.className = `cell ${(r+c)%2!==0 ? 'dark' : 'light'}`;
                        div.onclick = () => app.handleCell(r, c);

                        // Highlight valid moves if piece selected
                        if (state.selected && !state.activeSpell) {
                            const p = state.board[state.selected.r][state.selected.c];
                            const valid = Engine.getValidMoves(state.board, state.selected.r, state.selected.c, p, state.forcedPiece);
                            if (valid.find(m => m.r === r && m.c === c)) {
                                div.classList.add('highlight');
                            }
                        }
                        
                        // Highlight targets if spell active
                        if (state.activeSpell) div.classList.add('target');

                        // Draw Piece
                        if (cell) {
                            const pDiv = document.createElement('div');
                            pDiv.className = `piece ${cell.player}`;
                            if (cell.king) pDiv.classList.add('king');
                            if (cell.frozen) pDiv.classList.add('frozen');
                            if (cell.shielded) pDiv.classList.add('shielded');
                            if (state.selected && state.selected.r === r && state.selected.c === c) pDiv.classList.add('selected');
                            if (cell.king) pDiv.innerText = 'üëë';
                            div.appendChild(pDiv);
                        }
                        boardEl.appendChild(div);
                    });
                });
            },

            showFloatText(col, row, text) {
                const board = document.getElementById('board');
                const cellWidth = board.clientWidth / 8;
                const el = document.createElement('div');
                el.className = 'float-text';
                el.innerText = text;
                el.style.left = `${(col * cellWidth) + 10}px`;
                el.style.top = `${(row * cellWidth) + 10}px`;
                board.parentElement.appendChild(el);
                setTimeout(() => el.remove(), 1000);
            }
        };

        // -----------------------------------------------------
        // 5. APP CONTROLLER
        // -----------------------------------------------------
        window.app = {
            async createGame() {
                if (!isOnline) { alert("Config Missing!"); return; }
                const code = Math.floor(1000 + Math.random() * 9000).toString();
                state.roomId = code;
                state.role = 'red';
                state.board = Engine.createBoard();
                
                await setDoc(doc(db, "games", code), {
                    board: JSON.stringify(state.board),
                    turn: 'red',
                    stats: state.stats,
                    players: { red: userId },
                    winner: null
                });

                this.subscribe(code);
                this.showLobbyWait(code);
            },

            async joinGame() {
                const code = document.getElementById('room-input').value;
                if (!code) return;
                
                const ref = doc(db, "games", code);
                const snap = await getDoc(ref);
                if (snap.exists()) {
                    state.roomId = code;
                    state.role = 'blue';
                    await updateDoc(ref, { "players.blue": userId });
                    this.subscribe(code);
                } else {
                    document.getElementById('lobby-msg').innerText = "Room not found!";
                }
            },

            subscribe(id) {
                onSnapshot(doc(db, "games", id), (snap) => {
                    const d = snap.data();
                    if (!d) return;
                    
                    // Check if game ready
                    if (d.players.red && d.players.blue) {
                        document.getElementById('lobby-screen').classList.add('hidden');
                        document.getElementById('game-screen').classList.remove('hidden');
                    }

                    // Sync state
                    state.board = JSON.parse(d.board);
                    state.turn = d.turn;
                    state.stats = d.stats;
                    state.winner = d.winner;
                    state.forcedPiece = d.forcedPiece;
                    Renderer.draw();
                });
            },

            async pushState(newState) {
                // Optimistic update
                state = newState;
                Renderer.draw();
                
                if (isOnline && state.roomId) {
                    await updateDoc(doc(db, "games", state.roomId), {
                        board: JSON.stringify(state.board),
                        turn: state.turn,
                        stats: state.stats,
                        winner: state.winner,
                        forcedPiece: state.forcedPiece || null
                    });
                }
            },

            handleCell(r, c) {
                if (state.winner || state.turn !== state.role) return;

                // 1. Cast Spell?
                if (state.activeSpell) {
                    const newState = Engine.castSpell(state, r, c);
                    if (newState) this.pushState(newState);
                    return;
                }

                // 2. Select Piece?
                const clicked = state.board[r][c];
                if (clicked && clicked.player === state.role) {
                    // Check force
                    if (state.forcedPiece && (state.forcedPiece.r !== r || state.forcedPiece.c !== c)) return;
                    if (clicked.frozen) return; // Cannot select frozen

                    state.selected = {r, c};
                    Renderer.draw();
                    return;
                }

                // 3. Move?
                if (state.selected && !clicked) {
                    const p = state.board[state.selected.r][state.selected.c];
                    const validMoves = Engine.getValidMoves(state.board, state.selected.r, state.selected.c, p, state.forcedPiece);
                    const move = validMoves.find(m => m.r === r && m.c === c);
                    
                    if (move) {
                        const newState = Engine.processMove(state, state.selected.r, state.selected.c, move);
                        newState.selected = null;
                        this.pushState(newState);
                    } else {
                        state.selected = null;
                        Renderer.draw();
                    }
                }
            },

            clickSpell(id) {
                if (state.turn !== state.role) return;
                state.activeSpell = (state.activeSpell === id) ? null : id;
                Renderer.draw();
            },

            showLobbyWait(code) {
                document.querySelector('.card').innerHTML = `
                    <h3>Waiting...</h3>
                    <div style="font-size:3rem; color:var(--gold); letter-spacing:5px; margin:20px;">${code}</div>
                    <div>Share this code with your friend</div>
                `;
            }
        };

        // Init
        Renderer.init();
    </script>
</body>
</html>