<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RPG Checkers: Stable Core</title>
    <style>
        :root {
            --bg: #1a1a1a;
            --panel: #2d2d2d;
            --text: #e0e0e0;
            --red: #ff4444;
            --blue: #4488ff;
            --gold: #ffd700;
        }

        body {
            background: var(--bg); color: var(--text);
            font-family: sans-serif; margin: 0;
            display: flex; flex-direction: column; align-items: center;
            height: 100vh; overflow: hidden;
        }

        /* --- LOBBY --- */
        #lobby {
            position: fixed; inset: 0; background: var(--bg); z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            gap: 20px;
        }
        .card {
            background: var(--panel); padding: 40px; border-radius: 10px;
            text-align: center; border: 1px solid #444; width: 300px;
        }
        input, button {
            display: block; width: 100%; margin: 10px 0; padding: 10px;
            border-radius: 5px; border: none; font-size: 16px;
        }
        button { cursor: pointer; font-weight: bold; background: #555; color: white; }
        button:hover { background: #666; }
        button.primary { background: var(--blue); }

        /* --- GAME LAYOUT --- */
        #game {
            display: none; width: 100%; height: 100%;
            flex-direction: row; /* Desktop layout default */
        }

        .panel {
            width: 250px; background: var(--panel); padding: 20px;
            display: flex; flex-direction: column; gap: 20px;
            border-right: 1px solid #444;
        }
        .panel.right { border-left: 1px solid #444; border-right: none; }

        .board-area {
            flex: 1; display: flex; flex-direction: column;
            align-items: center; justify-content: center; position: relative;
        }

        /* --- STATS & SPELLS --- */
        .player-card { text-align: center; border: 2px solid transparent; padding: 10px; border-radius: 8px; }
        .player-card.active { border-color: var(--gold); background: #333; }
        
        .stat-bar { height: 8px; background: #111; margin: 5px 0; border-radius: 4px; overflow: hidden; }
        .fill { height: 100%; transition: width 0.3s; }
        .fill-xp { background: var(--gold); }
        .fill-mana { background: var(--blue); }

        .btn-spell {
            padding: 10px; margin: 5px 0; background: #444; color: white;
            border: 1px solid #555; border-radius: 5px; cursor: pointer;
            display: flex; justify-content: space-between; align-items: center;
        }
        .btn-spell:disabled { opacity: 0.3; cursor: not-allowed; }
        .btn-spell.active { border-color: var(--gold); background: #554400; }

        /* --- BOARD --- */
        #board {
            display: grid; grid-template-columns: repeat(8, 60px); grid-template-rows: repeat(8, 60px);
            border: 5px solid #444; background: #000;
        }
        .cell { width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; position: relative; }
        .cell.light { background: #e0e0e0; }
        .cell.dark { background: #444; }
        
        .cell.highlight { cursor: pointer; }
        .cell.highlight::after {
            content: ''; width: 20px; height: 20px; background: rgba(255, 215, 0, 0.6);
            border-radius: 50%; position: absolute; pointer-events: none;
        }
        .cell.target { box-shadow: inset 0 0 0 4px #a855f7; cursor: pointer; }

        .piece {
            width: 45px; height: 45px; border-radius: 50%;
            border: 3px solid rgba(0,0,0,0.3); font-weight: bold; font-size: 24px;
            display: flex; align-items: center; justify-content: center; color: white;
            position: relative; z-index: 10; transition: transform 0.2s;
        }
        .piece.red { background: var(--red); }
        .piece.blue { background: var(--blue); }
        .piece.king { border-color: var(--gold); color: var(--gold); }
        .piece.selected { transform: scale(1.2); box-shadow: 0 0 10px white; }
        
        /* Status Icons */
        .piece.frozen::after { content: '‚ùÑÔ∏è'; font-size: 20px; position: absolute; }
        .piece.shielded { box-shadow: 0 0 0 3px #00ff00; }

        /* --- LOGS & MODALS --- */
        #logs {
            position: absolute; bottom: 20px; width: 600px; height: 100px;
            background: rgba(0,0,0,0.7); overflow-y: auto; padding: 10px;
            border-radius: 5px; pointer-events: none; font-family: monospace;
        }
        .log-line { margin-bottom: 2px; text-shadow: 1px 1px 0 #000; }

        #turn-display {
            position: absolute; top: 20px; background: #333; padding: 10px 30px;
            border-radius: 20px; font-weight: bold; letter-spacing: 2px;
            border: 2px solid #555;
        }
        
        /* Cancel Button */
        #cancel-btn { 
            display: none; position: absolute; top: 70px; 
            padding: 5px 15px; background: #ff4444; border: none; color: white; cursor: pointer;
        }
    </style>
</head>
<body>

    <!-- LOBBY -->
    <div id="lobby">
        <div class="card">
            <h1>RPG CHECKERS</h1>
            <button class="primary" onclick="app.createGame()">CREATE ROOM</button>
            <p>‚Äî OR ‚Äî</p>
            <input id="room-code" placeholder="ENTER 4-DIGIT CODE" maxlength="4" style="text-transform:uppercase;">
            <button onclick="app.joinGame()">JOIN ROOM</button>
            <div id="lobby-status" style="color: var(--gold); margin-top: 10px;"></div>
        </div>
        <div id="waiting" class="card" style="display: none;">
            <h2>WAITING...</h2>
            <p>Room Code:</p>
            <h1 id="display-code" style="color: var(--gold); letter-spacing: 5px;">----</h1>
            <p>Share this with your opponent.</p>
        </div>
    </div>

    <!-- GAME UI -->
    <div id="game">
        <!-- LEFT PANEL (RED) -->
        <div class="panel">
            <div class="player-card" id="card-red">
                <h2>RED WARLOCKS</h2>
                <div>LVL <span id="lvl-red">1</span></div>
                <div class="stat-bar"><div class="fill fill-xp" id="xp-red" style="width:0%"></div></div>
                <div class="stat-bar"><div class="fill fill-mana" id="mana-red" style="width:100%"></div></div>
                <div>Mana: <span id="mana-text-red">2/5</span></div>
            </div>
            
            <h3>RED SPELLS</h3>
            <button class="btn-spell" id="spell-red-dash" onclick="game.toggleSpell('dash')">
                <span>‚ö° Dash</span> <span>2m</span>
            </button>
            <button class="btn-spell" id="spell-red-freeze" onclick="game.toggleSpell('freeze')">
                <span>‚ùÑÔ∏è Freeze</span> <span>3m</span>
            </button>
            <button class="btn-spell" id="spell-red-smite" onclick="game.toggleSpell('smite')">
                <span>üî• Smite</span> <span>4m</span>
            </button>
        </div>

        <!-- BOARD AREA -->
        <div class="board-area">
            <div id="turn-display">RED'S TURN</div>
            <button id="cancel-btn" onclick="game.cancelSpell()">CANCEL SPELL</button>
            <div id="board"></div>
            <div id="logs"></div>
        </div>

        <!-- RIGHT PANEL (BLUE) -->
        <div class="panel right">
            <div class="player-card" id="card-blue">
                <h2>BLUE PALADINS</h2>
                <div>LVL <span id="lvl-blue">1</span></div>
                <div class="stat-bar"><div class="fill fill-xp" id="xp-blue" style="width:0%"></div></div>
                <div class="stat-bar"><div class="fill fill-mana" id="mana-blue" style="width:100%"></div></div>
                <div>Mana: <span id="mana-text-blue">2/5</span></div>
            </div>

            <h3>BLUE SPELLS</h3>
            <button class="btn-spell" id="spell-blue-dash" onclick="game.toggleSpell('dash')">
                <span>‚ú® Dash</span> <span>2m</span>
            </button>
            <button class="btn-spell" id="spell-blue-freeze" onclick="game.toggleSpell('freeze')">
                <span>‚ùÑÔ∏è Freeze</span> <span>3m</span>
            </button>
            <button class="btn-spell" id="spell-blue-smite" onclick="game.toggleSpell('smite')">
                <span>üî® Smite</span> <span>4m</span>
            </button>
        </div>
    </div>

    <!-- LOGIC -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, updateDoc, onSnapshot, getDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyAw_6jPchQudpMb9m7ccOaH3uvx7P1QTXg",
            authDomain: "checkersrpg.firebaseapp.com",
            projectId: "checkersrpg",
            storageBucket: "checkersrpg.firebasestorage.app",
            messagingSenderId: "527317445442",
            appId: "1:527317445442:web:9c59dc55089c479ff076db",
            measurementId: "G-L7H2D9YXJT"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let myId = null;
        let myRole = null;
        let roomId = null;

        // AUTH
        signInAnonymously(auth).then(u => {
            myId = u.user.uid;
            console.log("Auth Success:", myId);
        }).catch(e => alert("Auth Failed: " + e.message));

        // --- GAME ENGINE ---
        const Engine = {
            state: {
                board: [],
                turn: 'red',
                stats: { 
                    red: { lvl: 1, xp: 0, maxXp: 100, mana: 2, maxMana: 5 }, 
                    blue: { lvl: 1, xp: 0, maxXp: 100, mana: 2, maxMana: 5 }
                },
                selected: null,
                activeSpell: null,
                forcedPiece: null,
                winner: null,
                logs: []
            },

            initBoard() {
                let b = [];
                for(let r=0; r<8; r++){
                    let row = [];
                    for(let c=0; c<8; c++){
                        let p = null;
                        if((r+c)%2 !== 0) {
                            if(r<3) p = {player:'blue', king:false, frozen:0};
                            if(r>4) p = {player:'red', king:false, frozen:0};
                        }
                        row.push({piece: p, hl: false, target: false});
                    }
                    b.push(row);
                }
                return b;
            },

            getValidMoves(r, c, piece) {
                if(piece.frozen > 0) return [];
                let moves = [];
                let forward = piece.player === 'red' ? -1 : 1;
                let dirs = piece.king ? [[-1,-1],[-1,1],[1,-1],[1,1]] : [[forward,-1],[forward,1]];

                dirs.forEach(([dr, dc]) => {
                    let nr = r+dr, nc = c+dc;
                    if(this.bounds(nr, nc)) {
                        // Walk (only if not forced)
                        if(!this.state.forcedPiece && !this.state.board[nr][nc].piece) {
                            moves.push({r:nr, c:nc});
                        }
                        // Jump
                        else if(this.state.board[nr][nc].piece && this.state.board[nr][nc].piece.player !== piece.player) {
                            let jr = nr+dr, jc = nc+dc;
                            if(this.bounds(jr, jc) && !this.state.board[jr][jc].piece) {
                                moves.push({r:jr, c:jc});
                            }
                        }
                    }
                });
                return moves;
            },

            bounds(r, c) { return r>=0 && r<8 && c>=0 && c<8; }
        };

        // --- UI & CONTROLLER ---
        window.game = {
            toggleSpell(spell) {
                if(Engine.state.turn !== myRole) return;
                
                // Toggle off
                if(Engine.state.activeSpell === spell) {
                    this.cancelSpell();
                    return;
                }

                Engine.state.activeSpell = spell;
                this.refreshBoardHighlights();
                this.render();
            },

            cancelSpell() {
                Engine.state.activeSpell = null;
                this.refreshBoardHighlights();
                this.render();
            },

            handleClick(r, c) {
                const s = Engine.state;
                if(s.winner || s.turn !== myRole) return;

                // 1. Cast Spell
                if(s.activeSpell) {
                    this.executeSpell(r, c);
                    return;
                }

                const cell = s.board[r][c];

                // 2. Select
                if(cell.piece && cell.piece.player === s.turn) {
                    if(s.forcedPiece && (s.forcedPiece.r !== r || s.forcedPiece.c !== c)) return;
                    if(cell.piece.frozen) return;

                    s.selected = {r, c};
                    this.refreshBoardHighlights();
                    this.render();
                }
                // 3. Move
                else if(cell.hl && s.selected) {
                    this.executeMove(s.selected.r, s.selected.c, r, c);
                }
            },

            refreshBoardHighlights() {
                const s = Engine.state;
                // Clear all
                s.board.forEach(row => row.forEach(c => { c.hl = false; c.target = false; }));

                // Spell Targets
                if(s.activeSpell) {
                    s.board.forEach((row, r) => row.forEach((cell, c) => {
                        const p = cell.piece;
                        if(s.activeSpell === 'smite' || s.activeSpell === 'freeze') {
                            if(p && p.player !== s.turn) cell.target = true;
                        } else if (s.activeSpell === 'dash') {
                            if(p && p.player === s.turn && !p.frozen) cell.target = true;
                        }
                    }));
                    return;
                }

                // Move Highlights
                if(s.selected) {
                    const p = s.board[s.selected.r][s.selected.c].piece;
                    const moves = Engine.getValidMoves(s.selected.r, s.selected.c, p);
                    moves.forEach(m => s.board[m.r][m.c].hl = true);
                }
            },

            async executeMove(fr, fc, tr, tc) {
                let s = JSON.parse(JSON.stringify(Engine.state)); // Copy State
                let p = s.board[fr][fc].piece;
                let isJump = Math.abs(tr - fr) > 1;
                let logText = "Moved.";

                // Execute
                s.board[tr][tc].piece = p;
                s.board[fr][fc].piece = null;
                s.selected = null;

                let turnEnd = true;
                s.forcedPiece = null;

                if(isJump) {
                    let midR = (fr+tr)/2, midC = (fc+tc)/2;
                    s.board[midR][midC].piece = null;
                    logText = "Enemy Crushed!";
                    
                    // XP
                    s.stats[s.turn].xp += 50;
                    if(s.stats[s.turn].xp >= s.stats[s.turn].maxXp) {
                        s.stats[s.turn].lvl++;
                        s.stats[s.turn].xp = 0;
                        s.stats[s.turn].maxMana += 2;
                        s.stats[s.turn].mana = s.stats[s.turn].maxMana;
                        logText = "LEVEL UP!";
                    }

                    // Combo Logic - Simplified Check
                    const forward = p.player === 'red' ? -1 : 1;
                    const dirs = p.king ? [[-1,-1],[-1,1],[1,-1],[1,1]] : [[forward,-1],[forward,1]];
                    let canJumpAgain = false;
                    dirs.forEach(([dr, dc]) => {
                        let jr=tr+dr+dr, jc=tc+dc+dc;
                        let mr=tr+dr, mc=tc+dc;
                        if(Engine.bounds(jr,jc) && !s.board[jr][jc].piece && s.board[mr][mc].piece && s.board[mr][mc].piece.player !== p.player) {
                            canJumpAgain = true;
                        }
                    });

                    if(canJumpAgain) {
                        s.forcedPiece = {r: tr, c: tc};
                        turnEnd = false;
                        logText = "COMBO!";
                    }
                }

                // King
                if((p.player==='red' && tr===0) || (p.player==='blue' && tr===7)) {
                    if(!p.king) { p.king = true; logText="KING!"; turnEnd=true; s.forcedPiece=null; }
                }

                if(turnEnd) this.nextTurn(s);
                
                await this.pushUpdate(s, logText);
            },

            async executeSpell(r, c) {
                const cell = Engine.state.board[r][c];
                if(!cell.target) return;

                let s = JSON.parse(JSON.stringify(Engine.state));
                let spell = s.activeSpell;
                let cost = spell==='smite'?4 : spell==='freeze'?3 : 2;
                let p = cell.piece;
                let log = "";

                // Deduct Mana
                s.stats[s.turn].mana -= cost;

                if(spell === 'smite') {
                    s.board[r][c].piece = null;
                    s.stats[s.turn].xp += 30;
                    log = "SMITE!";
                } else if(spell === 'freeze') {
                    p.frozen = 2; 
                    log = "FROZEN!";
                } else if(spell === 'dash') {
                    // Simple dash forward logic
                    let dir = s.turn === 'red' ? -1 : 1;
                    let tr = r + (dir*2);
                    if(Engine.bounds(tr, c) && !s.board[tr][c].piece) {
                        s.board[tr][c].piece = p;
                        s.board[r][c].piece = null;
                        log = "DASH!";
                    } else {
                        s.stats[s.turn].mana += cost; // Refund if fail
                        this.cancelSpell();
                        return;
                    }
                }

                s.activeSpell = null;
                this.nextTurn(s);
                await this.pushUpdate(s, log);
            },

            nextTurn(s) {
                let next = s.turn === 'red' ? 'blue' : 'red';
                // Mana
                if(s.stats[next].mana < s.stats[next].maxMana) s.stats[next].mana++;
                // Tick Effects
                s.board.forEach(row => row.forEach(c => {
                    if(c.piece && c.piece.player === next && c.piece.frozen > 0) c.piece.frozen--;
                }));
                s.turn = next;
                
                // Win Check
                let redAlive = s.board.some(r=>r.some(c=>c.piece && c.piece.player==='red'));
                let blueAlive = s.board.some(r=>r.some(c=>c.piece && c.piece.player==='blue'));
                if(!redAlive) s.winner = 'blue';
                if(!blueAlive) s.winner = 'red';
            },

            async pushUpdate(newState, logMsg) {
                // Clear highlights before saving
                newState.board.forEach(row => row.forEach(c => { c.hl = false; c.target = false; }));
                
                if(logMsg) newState.logs.push(`[${myRole.toUpperCase()}] ${logMsg}`);
                
                // Optimistic Local Update
                Engine.state = newState;
                this.render();

                // DB Update
                await updateDoc(doc(db, "games", roomId), {
                    board: JSON.stringify(newState.board),
                    turn: newState.turn,
                    stats: newState.stats,
                    forcedPiece: newState.forcedPiece,
                    winner: newState.winner,
                    logs: newState.logs
                });
            },

            render() {
                const s = Engine.state;
                
                // 1. Board
                const bEl = document.getElementById('board');
                bEl.innerHTML = '';
                s.board.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        let div = document.createElement('div');
                        div.className = `cell ${(r+c)%2!==0 ? 'dark' : 'light'}`;
                        if(cell.hl) div.classList.add('highlight');
                        if(cell.target) div.classList.add('target');
                        div.onclick = () => this.handleClick(r, c);

                        if(cell.piece) {
                            let p = document.createElement('div');
                            p.className = `piece ${cell.piece.player}`;
                            if(cell.piece.king) { p.classList.add('king'); p.innerText = 'üëë'; }
                            if(cell.piece.frozen) p.classList.add('frozen');
                            if(s.selected && s.selected.r===r && s.selected.c===c) p.classList.add('selected');
                            div.appendChild(p);
                        }
                        bEl.appendChild(div);
                    });
                });

                // 2. Stats
                ['red', 'blue'].forEach(role => {
                    let st = s.stats[role];
                    document.getElementById(`lvl-${role}`).innerText = st.lvl;
                    document.getElementById(`xp-${role}`).style.width = `${(st.xp/st.maxXp)*100}%`;
                    document.getElementById(`mana-${role}`).style.width = `${(st.mana/st.maxMana)*100}%`;
                    document.getElementById(`mana-text-${role}`).innerText = `${st.mana}/${st.maxMana}`;
                    
                    // Button states
                    let isMyTurn = s.turn === myRole && myRole === role;
                    ['dash', 'freeze', 'smite'].forEach(spell => {
                        let btn = document.getElementById(`spell-${role}-${spell}`);
                        if(btn) {
                            let cost = spell==='smite'?4 : spell==='freeze'?3 : 2;
                            btn.disabled = !isMyTurn || st.mana < cost;
                            btn.classList.toggle('active', s.activeSpell === spell);
                        }
                    });
                });

                // 3. UI Status
                document.getElementById('card-red').classList.toggle('active', s.turn === 'red');
                document.getElementById('card-blue').classList.toggle('active', s.turn === 'blue');
                document.getElementById('turn-display').innerText = s.winner ? `${s.winner.toUpperCase()} WINS!` : `${s.turn.toUpperCase()}'S TURN`;
                
                document.getElementById('cancel-btn').style.display = s.activeSpell ? 'block' : 'none';

                // 4. Logs
                let lEl = document.getElementById('logs');
                lEl.innerHTML = s.logs.slice(-5).reverse().map(l => `<div class="log-line">> ${l}</div>`).join('');
            }
        };

        // --- LOBBY CONTROLLER ---
        window.app = {
            async createGame() {
                if(!myId) return alert("Connecting... try again in 1s");
                let code = Math.floor(1000 + Math.random()*9000).toString();
                
                let initialState = Engine.state;
                initialState.board = Engine.initBoard(); // Clean board
                
                await setDoc(doc(db, "games", code), {
                    board: JSON.stringify(initialState.board),
                    turn: 'red',
                    stats: initialState.stats,
                    players: { red: myId },
                    winner: null,
                    logs: ["Room Created"]
                });

                this.enterLobby(code, 'red');
            },

            async joinGame() {
                if(!myId) return alert("Connecting...");
                let code = document.getElementById('room-code').value;
                if(code.length !== 4) return alert("Invalid Code");

                let ref = doc(db, "games", code);
                let snap = await getDoc(ref);
                
                if(snap.exists()) {
                    if(snap.data().players.blue) return alert("Full!");
                    await updateDoc(ref, { "players.blue": myId });
                    this.enterLobby(code, 'blue');
                } else {
                    alert("Room Not Found");
                }
            },

            enterLobby(code, role) {
                roomId = code;
                myRole = role;
                document.getElementById('lobby-main').style.display = 'none'; // hide main lobby
                
                // Show Waiting or Game
                document.getElementById('display-code').innerText = code;
                
                onSnapshot(doc(db, "games", code), (snap) => {
                    let d = snap.data();
                    if(!d) return;

                    // If both players, start game
                    if(d.players.red && d.players.blue) {
                        document.getElementById('lobby').style.display = 'none';
                        document.getElementById('game').style.display = 'flex';
                    } else {
                        document.getElementById('waiting').style.display = 'block';
                    }

                    // Sync
                    Engine.state.board = JSON.parse(d.board);
                    Engine.state.turn = d.turn;
                    Engine.state.stats = d.stats;
                    Engine.state.winner = d.winner;
                    Engine.state.forcedPiece = d.forcedPiece;
                    Engine.state.logs = d.logs || [];
                    
                    window.game.render();
                });
            }
        };
    </script>
</body>
</html>