<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RPG Checkers</title>
    <style>
        /* --- CSS STYLES --- */
        :root {
            --slate-900: #0f172a;
            --slate-950: #020617;
            --slate-800: #1e293b;
            --slate-700: #334155;
            --slate-400: #94a3b8;
            --slate-100: #f1f5f9;
            --red-600: #dc2626;
            --red-400: #f87171;
            --blue-600: #2563eb;
            --blue-400: #60a5fa;
            --cyan-500: #06b6d4;
            --emerald-500: #10b981;
            --amber-100: #fef3c7;
            --stone-800: #292524;
            --yellow-500: #eab308;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, sans-serif;
            background-color: var(--slate-950);
            color: var(--slate-100);
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile browsers */
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
            touch-action: manipulation;
        }

        /* --- LAYOUT --- */
        .game-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            position: relative;
        }

        /* Desktop/Tablet adjustments */
        @media (min-width: 768px) {
            .game-container { flex-direction: row; align-items: stretch; }
            .player-panel { width: 300px; height: auto !important; border-bottom: none !important; }
            .player-panel.left { border-right: 1px solid var(--slate-700); }
            .player-panel.right { border-left: 1px solid var(--slate-700); }
            .center-area { height: auto !important; }
        }

        /* --- PLAYER PANELS --- */
        .player-panel {
            background-color: rgba(15, 23, 42, 0.95);
            padding: 0.75rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            border-bottom: 1px solid var(--slate-700);
            transition: all 0.3s;
            z-index: 10;
        }
        
        .player-panel.active-turn { background-color: rgba(30, 41, 59, 1); box-shadow: 0 0 20px rgba(0,0,0,0.5); }

        .player-header { display: flex; align-items: center; gap: 0.75rem; }
        .player-header.reverse { flex-direction: row-reverse; text-align: right; }

        .avatar {
            width: 2.5rem; height: 2.5rem;
            border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 1.25rem; border: 2px solid;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            flex-shrink: 0;
        }
        .avatar.red { color: var(--red-400); background: var(--red-600); border-color: var(--red-400); }
        .avatar.blue { color: var(--blue-400); background: var(--blue-600); border-color: var(--blue-400); }

        .player-info { flex: 1; min-width: 0; }
        .player-name { font-size: 1rem; font-weight: bold; margin: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .player-lvl { font-size: 0.7rem; color: var(--slate-400); }
        .text-red { color: var(--red-400); }
        .text-blue { color: var(--blue-400); }

        /* Stats Bars - Compact for mobile */
        .stats-row { display: flex; gap: 0.5rem; }
        .stat-group { flex: 1; display: flex; flex-direction: column; gap: 2px; }
        .stat-label { display: flex; justify-content: space-between; font-size: 0.65rem; color: var(--slate-400); }
        .progress-bg { background: var(--slate-800); height: 6px; border-radius: 99px; overflow: hidden; position: relative; }
        .progress-bg.mana { height: 12px; border: 1px solid var(--slate-700); }
        .progress-fill { height: 100%; transition: width 0.3s ease; }
        .fill-xp { background: var(--yellow-500); }
        .fill-mana { background: linear-gradient(90deg, var(--blue-600), var(--blue-400)); }
        .mana-text { position: absolute; width: 100%; text-align: center; font-size: 8px; line-height: 10px; font-weight: bold; text-shadow: 0 1px 2px black; top: 0; }

        /* Spells - Scrollable on mobile */
        .spell-scroll {
            display: flex; gap: 0.5rem; overflow-x: auto; padding-bottom: 0.25rem;
            scrollbar-width: none; /* Hide scrollbar Firefox */
        }
        .spell-scroll::-webkit-scrollbar { display: none; } /* Hide scrollbar Chrome */

        .spell-btn {
            background: var(--slate-800); border: 1px solid var(--slate-700); color: white;
            padding: 0.4rem; border-radius: 6px; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-width: 60px; height: 60px; flex-shrink: 0;
            transition: all 0.2s; position: relative;
        }
        .spell-btn:hover:not(:disabled) { background: var(--slate-700); border-color: var(--slate-400); transform: translateY(-2px); }
        .spell-btn:disabled { opacity: 0.3; filter: grayscale(1); }
        
        .spell-icon { font-size: 1.25rem; margin-bottom: 2px; }
        .spell-name { font-size: 0.6rem; font-weight: bold; }
        .spell-cost { font-size: 0.55rem; color: var(--slate-400); }

        /* --- CENTER BOARD AREA --- */
        .center-area {
            flex: 1;
            background: var(--slate-900);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 0.5rem;
            overflow: hidden;
        }

        .turn-indicator {
            position: absolute; top: 1rem; left: 50%; transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.9); border: 1px solid var(--slate-700);
            padding: 0.4rem 1.2rem; border-radius: 99px;
            display: flex; align-items: center; gap: 0.5rem;
            font-weight: bold; font-size: 0.8rem; letter-spacing: 1px;
            z-index: 20; box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            transition: all 0.3s;
            pointer-events: auto; /* allow clicking cancel */
        }
        .turn-indicator.combo { border-color: var(--yellow-500); animation: pulse-border 1s infinite; }
        .turn-dot { width: 8px; height: 8px; border-radius: 50%; }
        .bg-red { background: var(--red-600); }
        .bg-blue { background: var(--blue-600); }
        .cancel-link { font-size: 0.7rem; color: var(--red-400); text-decoration: underline; cursor: pointer; margin-left: 8px; }

        /* Board */
        .board-container {
            width: 95vw; height: 95vw; /* Responsive square */
            max-width: 500px; max-height: 500px; /* Cap size */
            background: var(--slate-800);
            border: 4px solid var(--slate-700);
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            box-shadow: 0 10px 30px -5px rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            overflow: hidden;
            transition: transform 0.1s;
        }
        .board-container.shake { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }

        /* Cells */
        .cell { position: relative; display: flex; align-items: center; justify-content: center; }
        .cell.light { background: var(--amber-100); }
        .cell.dark { background: var(--stone-800); }
        
        .cell.highlight::after {
            content: ''; position: absolute; width: 25%; height: 25%;
            background: rgba(234, 179, 8, 0.8); border-radius: 50%;
            animation: pulse 1.5s infinite;
        }
        .cell.target { box-shadow: inset 0 0 0 3px #a855f7; cursor: pointer; }
        .cell.dimmed { filter: brightness(0.4); }

        /* Pieces */
        .piece {
            width: 85%; height: 85%; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 3px 6px rgba(0,0,0,0.6);
            transition: transform 0.2s;
            font-weight: bold; font-size: 1.2rem;
            position: relative; z-index: 5;
        }
        .piece.red { background: radial-gradient(circle at 30% 30%, #ef4444, #991b1b); border: 2px solid #7f1d1d; }
        .piece.blue { background: radial-gradient(circle at 30% 30%, #3b82f6, #1e40af); border: 2px solid #1e3a8a; }
        .piece.king { border: 3px solid var(--yellow-500); text-shadow: 0 2px 4px black; }
        .piece.selected { transform: scale(1.2); z-index: 10; border-color: white; box-shadow: 0 0 15px rgba(255,255,255,0.5); }
        
        /* Status Effects */
        .piece.frozen::after { content: '‚ùÑÔ∏è'; font-size: 1rem; position: absolute; }
        .piece.frozen { filter: brightness(1.2) hue-rotate(180deg) saturate(1.5); border-color: var(--cyan-500); }
        
        .piece.shielded { box-shadow: 0 0 0 2px var(--emerald-500), 0 0 10px var(--emerald-500); }
        .piece.shielded::before { content: 'üõ°Ô∏è'; font-size: 0.8rem; position: absolute; bottom: -2px; right: -2px; z-index: 2; }

        /* Log (Floating on Mobile) */
        .log-container {
            position: absolute; bottom: 10px; left: 10px; right: 10px;
            height: 60px; pointer-events: none;
            display: flex; flex-direction: column; justify-content: flex-end;
            text-shadow: 0 1px 2px black;
            font-size: 0.8rem; font-weight: bold;
        }
        .log-entry { 
            background: rgba(0,0,0,0.6); padding: 4px 8px; border-radius: 4px; 
            margin-top: 2px; align-self: center; width: fit-content;
            animation: fadeUp 3s forwards;
        }
        .log-combat { color: var(--red-400); }
        .log-level { color: var(--yellow-500); }
        .log-magic { color: #c084fc; }

        /* LOBBY & MODAL */
        #lobby-overlay, .modal {
            position: fixed; inset: 0; background: rgba(2, 6, 23, 0.95);
            z-index: 200; display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 1rem;
        }
        .lobby-box, .modal-box {
            background: var(--slate-800); padding: 2rem; border-radius: 1rem;
            border: 1px solid var(--slate-700); text-align: center;
            width: 100%; max-width: 400px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.5);
        }
        .lobby-title { font-size: 2rem; font-weight: bold; margin-bottom: 1.5rem; color: white; letter-spacing: 2px; }
        .lobby-btn, .modal-btn {
            width: 100%; padding: 1rem; margin-bottom: 0.75rem;
            background: var(--blue-600); border: none; border-radius: 0.5rem;
            color: white; font-weight: bold; font-size: 1rem; cursor: pointer;
        }
        .lobby-input {
            width: 100%; padding: 1rem; margin-bottom: 1rem;
            background: var(--slate-950); border: 1px solid var(--slate-700);
            border-radius: 0.5rem; color: white; font-size: 1.2rem; text-align: center;
            text-transform: uppercase; letter-spacing: 2px;
        }

        @keyframes pulse { 0% { transform: scale(0.9); opacity: 0.6; } 50% { transform: scale(1.2); opacity: 1; } 100% { transform: scale(0.9); opacity: 0.6; } }
        @keyframes shake { 10%, 90% { transform: translate3d(-1px, 0, 0); } 20%, 80% { transform: translate3d(2px, 0, 0); } }
        @keyframes fadeUp { 0% { opacity: 0; transform: translateY(10px); } 10% { opacity: 1; transform: translateY(0); } 80% { opacity: 1; } 100% { opacity: 0; } }
    </style>
</head>
<body class="in-lobby">

    <!-- LOBBY SCREEN -->
    <div id="lobby-overlay">
        <div class="lobby-box" id="lobby-main">
            <div class="lobby-title">RPG CHECKERS</div>
            <button class="lobby-btn" onclick="lobby.createGame()">CREATE GAME</button>
            <div style="margin: 1rem 0; color: var(--slate-400); font-size: 0.9rem;">‚Äî OR ‚Äî</div>
            <input type="text" id="room-code-input" class="lobby-input" placeholder="ROOM CODE" maxlength="6">
            <button class="lobby-btn" style="background: var(--slate-700);" onclick="lobby.joinGame()">JOIN GAME</button>
            <div id="lobby-status" style="margin-top: 1rem; color: var(--yellow-500); min-height: 1.5em;"></div>
        </div>
        <div class="lobby-box" id="lobby-waiting" style="display: none;">
            <div style="color: var(--slate-400); margin-bottom: 0.5rem;">ROOM CODE</div>
            <div id="display-room-code" style="font-size: 3rem; font-weight: bold; color: var(--yellow-500); letter-spacing: 4px; margin-bottom: 2rem;"></div>
            <div style="font-size: 0.9rem; color: white;">Waiting for opponent...</div>
        </div>
    </div>

    <div class="game-container">
        
        <!-- TOP PANEL (RED / OPPONENT usually) -->
        <div class="player-panel left" id="panel-red">
            <div class="player-header">
                <div class="avatar red" id="red-avatar">üëπ</div>
                <div class="player-info">
                    <div class="player-name text-red">Red Warlocks</div>
                    <div class="player-lvl">Level <span id="red-lvl">1</span></div>
                </div>
            </div>
            <div class="stats-row">
                <div class="stat-group">
                    <div class="progress-bg"><div class="progress-fill fill-xp" id="red-xp-bar" style="width: 0%"></div></div>
                </div>
                <div class="stat-group">
                    <div class="progress-bg mana"><div class="progress-fill fill-mana" id="red-mana-bar" style="width: 40%"></div></div>
                </div>
            </div>
            <!-- Scrollable Spells -->
            <div class="spell-scroll">
                <button class="spell-btn" id="btn-red-dash" onclick="game.activateSpell('dash')">
                    <span class="spell-icon">‚ö°</span>
                    <span class="spell-name">Dash</span>
                    <span class="spell-cost">2</span>
                </button>
                <button class="spell-btn" id="btn-red-shield" onclick="game.activateSpell('shield')">
                    <span class="spell-icon">üõ°Ô∏è</span>
                    <span class="spell-name">Shield</span>
                    <span class="spell-cost">2</span>
                </button>
                <button class="spell-btn" id="btn-red-freeze" onclick="game.activateSpell('freeze')">
                    <span class="spell-icon">‚ùÑÔ∏è</span>
                    <span class="spell-name">Freeze</span>
                    <span class="spell-cost">3</span>
                </button>
                <button class="spell-btn" id="btn-red-smite" onclick="game.activateSpell('smite')">
                    <span class="spell-icon">üî•</span>
                    <span class="spell-name">Smite</span>
                    <span class="spell-cost">4</span>
                </button>
                <button class="spell-btn" id="btn-red-revive" onclick="game.activateSpell('revive')">
                    <span class="spell-icon">üíÄ</span>
                    <span class="spell-name">Revive</span>
                    <span class="spell-cost">5</span>
                </button>
            </div>
        </div>

        <!-- CENTER BOARD -->
        <div class="center-area">
            <div class="turn-indicator" id="turn-badge">
                <div class="turn-dot" id="turn-dot"></div>
                <span id="turn-text">RED'S TURN</span>
                <span id="cancel-spell" class="cancel-link" style="display: none;" onclick="game.cancelSpell()">Cancel</span>
            </div>

            <div class="board-container" id="board"></div>
            <div class="log-container" id="game-log"></div>
        </div>

        <!-- BOTTOM PANEL (BLUE / YOU usually) -->
        <div class="player-panel right" id="panel-blue">
            <div class="player-header reverse">
                <div class="avatar blue" id="blue-avatar">üõ°Ô∏è</div>
                <div class="player-info" style="text-align: right;">
                    <div class="player-name text-blue">Blue Paladins</div>
                    <div class="player-lvl">Level <span id="blue-lvl">1</span></div>
                </div>
            </div>
            <div class="stats-row">
                <div class="stat-group">
                    <div class="progress-bg"><div class="progress-fill fill-xp" id="blue-xp-bar" style="width: 0%"></div></div>
                </div>
                <div class="stat-group">
                    <div class="progress-bg mana"><div class="progress-fill fill-mana" id="blue-mana-bar" style="width: 40%"></div></div>
                </div>
            </div>
            <div class="spell-scroll" style="justify-content: flex-end;">
                <button class="spell-btn" id="btn-blue-dash" onclick="game.activateSpell('dash')">
                    <span class="spell-icon">‚ú®</span>
                    <span class="spell-name">Dash</span>
                    <span class="spell-cost">2</span>
                </button>
                <button class="spell-btn" id="btn-blue-shield" onclick="game.activateSpell('shield')">
                    <span class="spell-icon">üõ°Ô∏è</span>
                    <span class="spell-name">Shield</span>
                    <span class="spell-cost">2</span>
                </button>
                <button class="spell-btn" id="btn-blue-freeze" onclick="game.activateSpell('freeze')">
                    <span class="spell-icon">‚ùÑÔ∏è</span>
                    <span class="spell-name">Freeze</span>
                    <span class="spell-cost">3</span>
                </button>
                <button class="spell-btn" id="btn-blue-smite" onclick="game.activateSpell('smite')">
                    <span class="spell-icon">üî®</span>
                    <span class="spell-name">Smite</span>
                    <span class="spell-cost">4</span>
                </button>
                <button class="spell-btn" id="btn-blue-revive" onclick="game.activateSpell('revive')">
                    <span class="spell-icon">‚ö∞Ô∏è</span>
                    <span class="spell-name">Revive</span>
                    <span class="spell-cost">5</span>
                </button>
            </div>
        </div>
    </div>

    <!-- WIN MODAL -->
    <div class="modal" id="win-modal" style="display: none;">
        <div class="modal-box">
            <div style="font-size: 4rem; margin-bottom: 1rem;">üèÜ</div>
            <h2 id="winner-name" style="font-size: 2rem; color: white; margin: 0;">WINNER!</h2>
            <button class="modal-btn" onclick="location.reload()" style="margin-top: 2rem;">Main Menu</button>
        </div>
    </div>

    <!-- FIREBASE & GAME LOGIC -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, updateDoc, onSnapshot, getDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        // --- PASTE YOUR FIREBASE CONFIG HERE ---
        const firebaseConfig = {
            apiKey: "AIzaSyAw_6jPchQudpMb9m7ccOaH3uvx7P1QTXg",
            authDomain: "checkersrpg.firebaseapp.com",
            projectId: "checkersrpg",
            storageBucket: "checkersrpg.firebasestorage.app",
            messagingSenderId: "527317445442",
            appId: "1:527317445442:web:9c59dc55089c479ff076db",
            measurementId: "G-L7H2D9YXJT"
        };

        // Fallback for demo mode if no config
        const isDemo = !firebaseConfig.apiKey;
        if(isDemo) console.warn("No Firebase Config found. Running in offline/demo mode.");

        let app, auth, db;
        if (!isDemo) {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
        }

        let myUserId = 'demo-user-' + Math.random();
        let myRoomId = null;
        let myRole = 'red'; // Default to red for local

        if (!isDemo) {
            signInAnonymously(auth).then((user) => {
                myUserId = user.user.uid;
            }).catch(e => console.error(e));
        }

        // --- LOBBY ---
        window.lobby = {
            async createGame() {
                if(isDemo) { startDemo('red'); return; }
                const roomId = Math.random().toString(36).substring(2, 8).toUpperCase();
                myRole = 'red';
                myRoomId = roomId;
                
                const initialData = {
                    board: JSON.stringify(game.createInitialBoard()),
                    turn: 'red',
                    stats: game.stats,
                    players: { red: myUserId, blue: null },
                    status: 'waiting',
                    winner: null,
                    forcedPiece: null,
                    logs: []
                };
                
                await setDoc(doc(db, "games", roomId), initialData);
                showWaitingScreen(roomId);
                this.subscribe(roomId);
            },

            async joinGame() {
                if(isDemo) { startDemo('blue'); return; }
                const roomId = document.getElementById('room-code-input').value.toUpperCase();
                if(roomId.length < 2) return;

                const ref = doc(db, "games", roomId);
                const snap = await getDoc(ref);
                
                if(snap.exists()) {
                    const data = snap.data();
                    if(data.players.blue && data.players.blue !== myUserId) {
                        alert("Room full!"); return;
                    }
                    myRole = 'blue';
                    myRoomId = roomId;
                    await updateDoc(ref, { "players.blue": myUserId, status: 'playing' });
                    this.subscribe(roomId);
                } else {
                    alert("Room not found");
                }
            },

            subscribe(roomId) {
                onSnapshot(doc(db, "games", roomId), (doc) => {
                    const data = doc.data();
                    if(!data) return;
                    if(data.status === 'playing') hideLobby();
                    
                    // Sync
                    game.board = JSON.parse(data.board);
                    game.turn = data.turn;
                    game.stats = data.stats;
                    game.forcedPiece = data.forcedPiece;
                    game.winner = data.winner;
                    
                    // Logs
                    const logEl = document.getElementById('game-log');
                    logEl.innerHTML = '';
                    if(data.logs) data.logs.slice(-3).forEach(l => game.renderLog(l.msg, l.type));

                    if(data.winner) game.winGame(data.winner);
                    game.render();
                });
            }
        };

        function startDemo(role) {
            myRole = role; // In demo, we play both, but let's pretend
            hideLobby();
            game.init();
        }

        function showWaitingScreen(code) {
            document.getElementById('lobby-main').style.display = 'none';
            document.getElementById('lobby-waiting').style.display = 'block';
            document.getElementById('display-room-code').textContent = code;
        }

        function hideLobby() {
            document.body.classList.remove('in-lobby');
            document.getElementById('lobby-overlay').style.display = 'none';
        }

        // --- GAME LOGIC ---
        window.game = {
            board: [],
            turn: 'red',
            stats: { red: {level:1, xp:0, xpNext:100, mana:2, maxMana:5}, blue: {level:1, xp:0, xpNext:100, mana:2, maxMana:5} },
            activeSpell: null,
            forcedPiece: null,
            selected: null,

            createInitialBoard() {
                let b = [];
                for(let r=0; r<8; r++) {
                    const row = [];
                    for(let c=0; c<8; c++) {
                        let piece = null;
                        if((r+c)%2 !== 0) {
                            if(r < 3) piece = { player: 'blue', isKing: false, frozen: 0, shielded: 0 };
                            if(r > 4) piece = { player: 'red', isKing: false, frozen: 0, shielded: 0 };
                        }
                        row.push({ piece: piece, highlight: false, target: false });
                    }
                    b.push(row);
                }
                return b;
            },

            init() {
                this.board = this.createInitialBoard();
                this.render();
            },

            // CORE NETWORK
            async pushUpdate(newBoard, newStats, nextTurn, newForcedPiece, logMsg, logType) {
                if(isDemo) {
                    this.board = newBoard; this.stats = newStats; this.turn = nextTurn; 
                    this.forcedPiece = newForcedPiece; 
                    if(logMsg) this.renderLog(logMsg, logType);
                    this.render();
                    return;
                }
                
                const ref = doc(db, "games", myRoomId);
                const snap = await getDoc(ref);
                const logs = snap.data().logs || [];
                if(logMsg) logs.push({msg: logMsg, type: logType});
                
                await updateDoc(ref, {
                    board: JSON.stringify(newBoard),
                    stats: newStats,
                    turn: nextTurn,
                    forcedPiece: newForcedPiece,
                    logs: logs
                });
            },

            // --- MOVES ---
            handleClick(r, c) {
                const isMyTurn = isDemo ? true : (this.turn === myRole);
                if(!isMyTurn || this.winner) return;

                if(this.activeSpell) { this.castSpell(r, c); return; }

                const cell = this.board[r][c];
                
                // Select
                if(cell.piece && cell.piece.player === this.turn) {
                    if(this.forcedPiece && (this.forcedPiece.r !== r || this.forcedPiece.c !== c)) return;
                    if(cell.piece.frozen > 0) return;

                    this.selected = {r, c};
                    this.highlightMoves(r, c, cell.piece);
                    this.render();
                }
                // Move
                else if(cell.highlight && this.selected) {
                    this.movePiece(this.selected.r, this.selected.c, r, c);
                }
            },

            highlightMoves(r, c, piece) {
                this.board.forEach(row => row.forEach(cell => cell.highlight = false));
                this.getValidMoves(r, c, piece).forEach(m => {
                    this.board[m.r][m.c].highlight = true;
                });
            },

            getValidMoves(r, c, piece) {
                if(piece.frozen > 0) return [];
                const moves = [];
                const forward = piece.player === 'red' ? -1 : 1;
                const dirs = piece.isKing ? [-1, 1] : [forward];

                dirs.forEach(dr => {
                    [-1, 1].forEach(dc => {
                        const nr = r + dr, nc = c + dc;
                        if(this.isValid(nr, nc)) {
                            // Walk
                            if(!this.forcedPiece && !this.board[nr][nc].piece) {
                                moves.push({r: nr, c: nc});
                            }
                            // Jump
                            else if(this.board[nr][nc].piece && this.board[nr][nc].piece.player !== piece.player) {
                                // Check if enemy is shielded
                                if(this.board[nr][nc].piece.shielded > 0) return;

                                const jr = nr + dr, jc = nc + dc;
                                if(this.isValid(jr, jc) && !this.board[jr][jc].piece) {
                                    moves.push({r: jr, c: jc});
                                }
                            }
                        }
                    });
                });
                return moves;
            },

            async movePiece(fr, fc, tr, tc) {
                let nextBoard = JSON.parse(JSON.stringify(this.board));
                let nextStats = JSON.parse(JSON.stringify(this.stats));
                const piece = nextBoard[fr][fc].piece;
                const isJump = Math.abs(tr - fr) > 1;
                let logMsg = '';
                
                nextBoard[tr][tc].piece = piece;
                nextBoard[fr][fc].piece = null;
                nextBoard.forEach(row => row.forEach(c => c.highlight = false));

                let nextForcedPiece = null;
                let turnEnds = true;

                if(isJump) {
                    const midR = (fr + tr) / 2;
                    const midC = (fc + tc) / 2;
                    nextBoard[midR][midC].piece = null;
                    logMsg = "Enemy Crushed!";
                    
                    nextStats[this.turn].xp += 50;
                    if(nextStats[this.turn].xp >= nextStats[this.turn].xpNext) {
                        nextStats[this.turn].level++;
                        nextStats[this.turn].xp = 0;
                        nextStats[this.turn].maxMana += 2;
                        nextStats[this.turn].mana = nextStats[this.turn].maxMana;
                        logMsg = "LEVEL UP!";
                    }

                    // Combo Check
                    const dummyPiece = nextBoard[tr][tc].piece; 
                    const forward = dummyPiece.player === 'red' ? -1 : 1;
                    const dirs = dummyPiece.isKing ? [-1, 1] : [forward];
                    let canJumpAgain = false;
                    
                    dirs.forEach(dr => {
                        [-1, 1].forEach(dc => {
                            const nr = tr + dr, nc = tc + dc;
                            const jr = nr + dr, jc = nc + dc;
                            if(this.isValid(jr, jc) && !nextBoard[jr][jc].piece && nextBoard[nr][nc].piece && nextBoard[nr][nc].piece.player !== dummyPiece.player) {
                                if(nextBoard[nr][nc].piece.shielded === 0) canJumpAgain = true;
                            }
                        });
                    });

                    if(canJumpAgain) {
                        nextForcedPiece = {r: tr, c: tc};
                        turnEnds = false;
                        logMsg = "COMBO!";
                    }
                }

                // King Promotion
                if((piece.player==='red' && tr===0) || (piece.player==='blue' && tr===7)) {
                    if(!piece.isKing) {
                        piece.isKing = true;
                        logMsg = "KING PROMOTION!";
                        turnEnds = true; // End turn on promo
                        nextForcedPiece = null;
                    }
                }

                let nextTurn = this.turn;
                if(turnEnds) {
                    nextTurn = this.turn === 'red' ? 'blue' : 'red';
                    if(nextStats[nextTurn].mana < nextStats[nextTurn].maxMana) nextStats[nextTurn].mana++;
                    this.tickStatusEffects(nextBoard, nextTurn);
                }

                await this.pushUpdate(nextBoard, nextStats, nextTurn, nextForcedPiece, logMsg, 'combat');
                this.selected = null;
            },

            // --- SPELLS ---
            activateSpell(spellName) {
                const isMyTurn = isDemo ? true : (this.turn === myRole);
                if(!isMyTurn) return;

                if(this.activeSpell === spellName) { this.cancelSpell(); return; }
                this.activeSpell = spellName;
                
                this.board.forEach((row, r) => row.forEach((cell, c) => {
                    cell.target = false; cell.highlight = false;
                    const p = cell.piece;
                    
                    if(spellName === 'smite' || spellName === 'freeze') {
                        if(p && p.player !== this.turn && p.shielded === 0) cell.target = true;
                    } 
                    else if(spellName === 'dash' || spellName === 'shield') {
                        if(p && p.player === this.turn && p.frozen === 0) cell.target = true;
                    }
                    else if(spellName === 'revive') {
                        // Target Empty back row
                        const backRow = this.turn === 'red' ? 7 : 0;
                        if(r === backRow && !p) cell.target = true;
                    }
                }));
                this.render();
            },

            cancelSpell() {
                this.activeSpell = null;
                this.board.forEach(r => r.forEach(c => c.target = false));
                this.render();
            },

            async castSpell(r, c) {
                if(!this.board[r][c].target) return;
                
                let nextBoard = JSON.parse(JSON.stringify(this.board));
                let nextStats = JSON.parse(JSON.stringify(this.stats));
                let logMsg = '';
                let spellCost = 0;

                if(this.activeSpell === 'smite') {
                    spellCost = 4; nextBoard[r][c].piece = null; logMsg = "SMITE!";
                } else if (this.activeSpell === 'freeze') {
                    spellCost = 3; nextBoard[r][c].piece.frozen = 2; logMsg = "FROZEN!";
                } else if (this.activeSpell === 'shield') {
                    spellCost = 2; nextBoard[r][c].piece.shielded = 2; logMsg = "SHIELDED!";
                } else if (this.activeSpell === 'revive') {
                    spellCost = 5; 
                    nextBoard[r][c].piece = { player: this.turn, isKing: false, frozen: 0, shielded: 0 };
                    logMsg = "REVIVED!";
                } else if (this.activeSpell === 'dash') {
                    spellCost = 2;
                    const piece = nextBoard[r][c].piece;
                    const dir = this.turn === 'red' ? -1 : 1;
                    let tr = r + (dir*2);
                    if(tr<0) tr=0; if(tr>7) tr=7;
                    if(this.isValid(tr, c) && !nextBoard[tr][c].piece) {
                        nextBoard[tr][c].piece = piece; nextBoard[r][c].piece = null; logMsg = "DASH!";
                    } else {
                        // Fizzle logic if blocked?
                        logMsg = "DASH BLOCKED!";
                    }
                }

                nextStats[this.turn].mana -= spellCost;
                
                let nextTurn = this.turn === 'red' ? 'blue' : 'red';
                if(nextStats[nextTurn].mana < nextStats[nextTurn].maxMana) nextStats[nextTurn].mana++;
                this.tickStatusEffects(nextBoard, nextTurn);

                await this.pushUpdate(nextBoard, nextStats, nextTurn, null, logMsg, 'magic');
                this.activeSpell = null;
            },

            tickStatusEffects(board, newTurnPlayer) {
                board.forEach(row => row.forEach(cell => {
                    if(cell.piece && cell.piece.player === newTurnPlayer) {
                        if(cell.piece.frozen > 0) cell.piece.frozen--;
                        if(cell.piece.shielded > 0) cell.piece.shielded--;
                    }
                }));
            },

            isValid(r, c) { return r>=0 && r<8 && c>=0 && c<8; },

            renderLog(msg, type) {
                const el = document.getElementById('game-log');
                const div = document.createElement('div');
                div.className = `log-entry log-${type}`;
                div.textContent = msg;
                el.appendChild(div); // Bottom up
                if(el.children.length > 3) el.removeChild(el.firstChild);
            },

            winGame(winner) {
                document.getElementById('win-modal').style.display = 'flex';
                document.getElementById('winner-name').textContent = winner + " WINS!";
                document.getElementById('winner-name').style.color = winner === 'red' ? 'var(--red-400)' : 'var(--blue-400)';
            },

            render() {
                // Board
                const boardEl = document.getElementById('board');
                boardEl.innerHTML = '';
                this.board.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        const div = document.createElement('div');
                        div.className = `cell ${(r+c)%2===0 ? 'light' : 'dark'}`;
                        if(cell.highlight) div.classList.add('highlight');
                        if(cell.target) div.classList.add('target');
                        if(this.activeSpell && !cell.target) div.classList.add('dimmed');
                        div.onclick = () => this.handleClick(r, c);

                        if(cell.piece) {
                            const p = document.createElement('div');
                            p.className = `piece ${cell.piece.player}`;
                            if(cell.piece.isKing) p.classList.add('king');
                            if(cell.piece.frozen > 0) p.classList.add('frozen');
                            if(cell.piece.shielded > 0) p.classList.add('shielded');
                            if(this.selected && this.selected.r===r && this.selected.c===c) p.classList.add('selected');
                            if(cell.piece.isKing) p.innerText = 'üëë';
                            div.appendChild(p);
                        }
                        boardEl.appendChild(div);
                    });
                });

                // Stats UI
                const p = this.turn; 
                // Toggle active panel visual
                document.getElementById('panel-red').classList.toggle('active-turn', p==='red');
                document.getElementById('panel-blue').classList.toggle('active-turn', p==='blue');

                ['red', 'blue'].forEach(role => {
                    const s = this.stats[role];
                    document.getElementById(`${role}-lvl`).textContent = s.level;
                    document.getElementById(`${role}-xp-bar`).style.width = `${(s.xp/s.xpNext)*100}%`;
                    document.getElementById(`${role}-mana-bar`).style.width = `${(s.mana/s.maxMana)*100}%`;
                    
                    // Buttons
                    const isMyTurn = isDemo ? (p===role) : (p===role && myRole===role);
                    document.getElementById(`btn-${role}-dash`).disabled = !(isMyTurn && s.mana>=2);
                    document.getElementById(`btn-${role}-shield`).disabled = !(isMyTurn && s.mana>=2);
                    document.getElementById(`btn-${role}-freeze`).disabled = !(isMyTurn && s.mana>=3);
                    document.getElementById(`btn-${role}-smite`).disabled = !(isMyTurn && s.mana>=4);
                    document.getElementById(`btn-${role}-revive`).disabled = !(isMyTurn && s.mana>=5);
                });

                // Turn Badge
                const badge = document.getElementById('turn-badge');
                const dot = document.getElementById('turn-dot');
                const txt = document.getElementById('turn-text');
                const cancel = document.getElementById('cancel-spell');

                dot.className = `turn-dot bg-${p}`;
                if(this.forcedPiece) {
                    badge.className = 'turn-indicator combo';
                    txt.textContent = "JUMP AGAIN!";
                    cancel.style.display = 'none';
                } else if(this.activeSpell) {
                    badge.className = 'turn-indicator';
                    txt.textContent = this.activeSpell.toUpperCase();
                    cancel.style.display = 'inline';
                } else {
                    badge.className = 'turn-indicator';
                    txt.textContent = `${p.toUpperCase()}'S TURN`;
                    cancel.style.display = 'none';
                }
            }
        };
    </script>
</body>
</html>